<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
        <meta name="robots" content="noindex,nofollow" />
        <style>
            /* Copyright (c) 2010, Yahoo! Inc. All rights reserved. Code licensed under the BSD License: http://developer.yahoo.com/yui/license.html */
            html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var{font-style:normal;font-weight:normal;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:text-top;}sub{vertical-align:text-bottom;}input,textarea,select{font-family:inherit;font-size:inherit;font-weight:inherit;}input,textarea,select{*font-size:100%;}legend{color:#000;}

            html { background: #eee; padding: 10px }
            img { border: 0; }
            #sf-resetcontent { width:970px; margin:0 auto; }
                        .sf-reset { font: 11px Verdana, Arial, sans-serif; color: #333 }
            .sf-reset .clear { clear:both; height:0; font-size:0; line-height:0; }
            .sf-reset .clear_fix:after { display:block; height:0; clear:both; visibility:hidden; }
            .sf-reset .clear_fix { display:inline-block; }
            .sf-reset * html .clear_fix { height:1%; }
            .sf-reset .clear_fix { display:block; }
            .sf-reset, .sf-reset .block { margin: auto }
            .sf-reset abbr { border-bottom: 1px dotted #000; cursor: help; }
            .sf-reset p { font-size:14px; line-height:20px; color:#868686; padding-bottom:20px }
            .sf-reset strong { font-weight:bold; }
            .sf-reset a { color:#6c6159; }
            .sf-reset a img { border:none; }
            .sf-reset a:hover { text-decoration:underline; }
            .sf-reset em { font-style:italic; }
            .sf-reset h1, .sf-reset h2 { font: 20px Georgia, "Times New Roman", Times, serif }
            .sf-reset h2 span { background-color: #fff; color: #333; padding: 6px; float: left; margin-right: 10px; }
            .sf-reset .traces li { font-size:12px; padding: 2px 4px; list-style-type:decimal; margin-left:20px; }
            .sf-reset .block { background-color:#FFFFFF; padding:10px 28px; margin-bottom:20px;
                -webkit-border-bottom-right-radius: 16px;
                -webkit-border-bottom-left-radius: 16px;
                -moz-border-radius-bottomright: 16px;
                -moz-border-radius-bottomleft: 16px;
                border-bottom-right-radius: 16px;
                border-bottom-left-radius: 16px;
                border-bottom:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
            }
            .sf-reset .block_exception { background-color:#ddd; color: #333; padding:20px;
                -webkit-border-top-left-radius: 16px;
                -webkit-border-top-right-radius: 16px;
                -moz-border-radius-topleft: 16px;
                -moz-border-radius-topright: 16px;
                border-top-left-radius: 16px;
                border-top-right-radius: 16px;
                border-top:1px solid #ccc;
                border-right:1px solid #ccc;
                border-left:1px solid #ccc;
                overflow: hidden;
                word-wrap: break-word;
            }
            .sf-reset li a { background:none; color:#868686; text-decoration:none; }
            .sf-reset li a:hover { background:none; color:#313131; text-decoration:underline; }
            .sf-reset ol { padding: 10px 0; }
            .sf-reset h1 { background-color:#FFFFFF; padding: 15px 28px; margin-bottom: 20px;
                -webkit-border-radius: 10px;
                -moz-border-radius: 10px;
                border-radius: 10px;
                border: 1px solid #ccc;
            }
        </style>
    </head>
    <body>
                    <div id="sf-resetcontent" class="sf-reset">
                <h1>Whoops, looks like something went wrong.</h1>
                                        <div class="block_exception clear_fix">
                            <h2><span>1/1</span> <abbr title="RuntimeException">RuntimeException</abbr>: Failed to write cache file "/home/darek/Projekty/www/words2/app/cache/dev/classes.php".</h2>
                        </div>
                        <div class="block">
                            <ol class="traces list_exception">
       <li> in /home/darek/Projekty/www/words2/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 239</li>
       <li>at <abbr title="Symfony\Component\ClassLoader\ClassCollectionLoader">ClassCollectionLoader</abbr>::writeCacheFile('/home/darek/Projekty/www/words2/app/cache/dev/classes.php', '&lt;?php 
namespace Symfony\Component\EventDispatcher
{
interface EventSubscriberInterface
{
public static function getSubscribedEvents();
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
abstract class SessionListener implements EventSubscriberInterface
{
public function onKernelRequest(GetResponseEvent $event)
{
if (HttpKernelInterface::MASTER_REQUEST !== $event-&gt;getRequestType()) {
return;
}
$request = $event-&gt;getRequest();
$session = $this-&gt;getSession();
if (null === $session || $request-&gt;hasSession()) {
return;
}
$request-&gt;setSession($session);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(&#039;onKernelRequest&#039;, 128),
);
}
abstract protected function getSession();
}
}
namespace Symfony\Bundle\FrameworkBundle\EventListener
{
use Symfony\Component\HttpKernel\EventListener\SessionListener as BaseSessionListener;
use Symfony\Component\DependencyInjection\ContainerInterface;
class SessionListener extends BaseSessionListener
{
private $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
protected function getSession()
{
if (!$this-&gt;container-&gt;has(&#039;session&#039;)) {
return null;
}
return $this-&gt;container-&gt;get(&#039;session&#039;);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
interface SessionStorageInterface
{
public function start();
public function isStarted();
public function getId();
public function setId($id);
public function getName();
public function setName($name);
public function regenerate($destroy = false, $lifetime = null);
public function save();
public function clear();
public function getBag($name);
public function registerBag(SessionBagInterface $bag);
public function getMetadataBag();
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\SessionBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeSessionHandler;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\NativeProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy;
class NativeSessionStorage implements SessionStorageInterface
{
protected $bags;
protected $started = false;
protected $closed = false;
protected $saveHandler;
protected $metadataBag;
public function __construct(array $options = array(), $handler = null, MetadataBag $metaBag = null)
{
session_cache_limiter(&#039;&#039;); ini_set(&#039;session.use_cookies&#039;, 1);
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
session_register_shutdown();
} else {
register_shutdown_function(&#039;session_write_close&#039;);
}
$this-&gt;setMetadataBag($metaBag);
$this-&gt;setOptions($options);
$this-&gt;setSaveHandler($handler);
}
public function getSaveHandler()
{
return $this-&gt;saveHandler;
}
public function start()
{
if ($this-&gt;started &amp;&amp; !$this-&gt;closed) {
return true;
}
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;) &amp;&amp; \PHP_SESSION_ACTIVE === session_status()) {
throw new \RuntimeException(&#039;Failed to start the session: already started by PHP.&#039;);
}
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&lt;&#039;) &amp;&amp; isset($_SESSION) &amp;&amp; session_id()) {
throw new \RuntimeException(&#039;Failed to start the session: already started by PHP ($_SESSION is set).&#039;);
}
if (ini_get(&#039;session.use_cookies&#039;) &amp;&amp; headers_sent($file, $line)) {
throw new \RuntimeException(sprintf(&#039;Failed to start the session because headers have already been sent by &quot;%s&quot; at line %d.&#039;, $file, $line));
}
if (!session_start()) {
throw new \RuntimeException(&#039;Failed to start the session&#039;);
}
$this-&gt;loadSession();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(true);
}
return true;
}
public function getId()
{
if (!$this-&gt;started &amp;&amp; !$this-&gt;closed) {
return&#039;&#039;; }
return $this-&gt;saveHandler-&gt;getId();
}
public function setId($id)
{
$this-&gt;saveHandler-&gt;setId($id);
}
public function getName()
{
return $this-&gt;saveHandler-&gt;getName();
}
public function setName($name)
{
$this-&gt;saveHandler-&gt;setName($name);
}
public function regenerate($destroy = false, $lifetime = null)
{
if (null !== $lifetime) {
ini_set(&#039;session.cookie_lifetime&#039;, $lifetime);
}
if ($destroy) {
$this-&gt;metadataBag-&gt;stampNew();
}
$ret = session_regenerate_id($destroy);
if (&#039;files&#039;=== $this-&gt;getSaveHandler()-&gt;getSaveHandlerName()) {
session_write_close();
if (isset($_SESSION)) {
$backup = $_SESSION;
session_start();
$_SESSION = $backup;
} else {
session_start();
}
$this-&gt;loadSession();
}
return $ret;
}
public function save()
{
session_write_close();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(false);
}
$this-&gt;closed = true;
$this-&gt;started = false;
}
public function clear()
{
foreach ($this-&gt;bags as $bag) {
$bag-&gt;clear();
}
$_SESSION = array();
$this-&gt;loadSession();
}
public function registerBag(SessionBagInterface $bag)
{
$this-&gt;bags[$bag-&gt;getName()] = $bag;
}
public function getBag($name)
{
if (!isset($this-&gt;bags[$name])) {
throw new \InvalidArgumentException(sprintf(&#039;The SessionBagInterface %s is not registered.&#039;, $name));
}
if ($this-&gt;saveHandler-&gt;isActive() &amp;&amp; !$this-&gt;started) {
$this-&gt;loadSession();
} elseif (!$this-&gt;started) {
$this-&gt;start();
}
return $this-&gt;bags[$name];
}
public function setMetadataBag(MetadataBag $metaBag = null)
{
if (null === $metaBag) {
$metaBag = new MetadataBag();
}
$this-&gt;metadataBag = $metaBag;
}
public function getMetadataBag()
{
return $this-&gt;metadataBag;
}
public function isStarted()
{
return $this-&gt;started;
}
public function setOptions(array $options)
{
$validOptions = array_flip(array(&#039;cache_limiter&#039;,&#039;cookie_domain&#039;,&#039;cookie_httponly&#039;,&#039;cookie_lifetime&#039;,&#039;cookie_path&#039;,&#039;cookie_secure&#039;,&#039;entropy_file&#039;,&#039;entropy_length&#039;,&#039;gc_divisor&#039;,&#039;gc_maxlifetime&#039;,&#039;gc_probability&#039;,&#039;hash_bits_per_character&#039;,&#039;hash_function&#039;,&#039;name&#039;,&#039;referer_check&#039;,&#039;serialize_handler&#039;,&#039;use_cookies&#039;,&#039;use_only_cookies&#039;,&#039;use_trans_sid&#039;,&#039;upload_progress.enabled&#039;,&#039;upload_progress.cleanup&#039;,&#039;upload_progress.prefix&#039;,&#039;upload_progress.name&#039;,&#039;upload_progress.freq&#039;,&#039;upload_progress.min-freq&#039;,&#039;url_rewriter.tags&#039;,
));
foreach ($options as $key =&gt; $value) {
if (isset($validOptions[$key])) {
ini_set(&#039;session.&#039;.$key, $value);
}
}
}
public function setSaveHandler($saveHandler = null)
{
if (!$saveHandler instanceof AbstractProxy &amp;&amp;
!$saveHandler instanceof NativeSessionHandler &amp;&amp;
!$saveHandler instanceof \SessionHandlerInterface &amp;&amp;
null !== $saveHandler) {
throw new \InvalidArgumentException(&#039;Must be instance of AbstractProxy or NativeSessionHandler; implement \SessionHandlerInterface; or be null.&#039;);
}
if (!$saveHandler instanceof AbstractProxy &amp;&amp; $saveHandler instanceof \SessionHandlerInterface) {
$saveHandler = new SessionHandlerProxy($saveHandler);
} elseif (!$saveHandler instanceof AbstractProxy) {
$saveHandler = version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;) ?
new SessionHandlerProxy(new \SessionHandler()) : new NativeProxy();
}
$this-&gt;saveHandler = $saveHandler;
if ($this-&gt;saveHandler instanceof \SessionHandlerInterface) {
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
session_set_save_handler($this-&gt;saveHandler, false);
} else {
session_set_save_handler(
array($this-&gt;saveHandler,&#039;open&#039;),
array($this-&gt;saveHandler,&#039;close&#039;),
array($this-&gt;saveHandler,&#039;read&#039;),
array($this-&gt;saveHandler,&#039;write&#039;),
array($this-&gt;saveHandler,&#039;destroy&#039;),
array($this-&gt;saveHandler,&#039;gc&#039;)
);
}
}
}
protected function loadSession(array &amp;$session = null)
{
if (null === $session) {
$session = &amp;$_SESSION;
}
$bags = array_merge($this-&gt;bags, array($this-&gt;metadataBag));
foreach ($bags as $bag) {
$key = $bag-&gt;getStorageKey();
$session[$key] = isset($session[$key]) ? $session[$key] : array();
$bag-&gt;initialize($session[$key]);
}
$this-&gt;started = true;
$this-&gt;closed = false;
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage
{
use Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy;
use Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeSessionHandler;
class PhpBridgeSessionStorage extends NativeSessionStorage
{
public function __construct($handler = null, MetadataBag $metaBag = null)
{
$this-&gt;setMetadataBag($metaBag);
$this-&gt;setSaveHandler($handler);
}
public function start()
{
if ($this-&gt;started &amp;&amp; !$this-&gt;closed) {
return true;
}
$this-&gt;loadSession();
if (!$this-&gt;saveHandler-&gt;isWrapper() &amp;&amp; !$this-&gt;saveHandler-&gt;isSessionHandlerInterface()) {
$this-&gt;saveHandler-&gt;setActive(true);
}
return true;
}
public function clear()
{
foreach ($this-&gt;bags as $bag) {
$bag-&gt;clear();
}
$this-&gt;loadSession();
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Handler
{
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
class NativeSessionHandler extends \SessionHandler {}
} else {
class NativeSessionHandler {}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Handler
{
class NativeFileSessionHandler extends NativeSessionHandler
{
public function __construct($savePath = null)
{
if (null === $savePath) {
$savePath = ini_get(&#039;session.save_path&#039;);
}
$baseDir = $savePath;
if ($count = substr_count($savePath,&#039;;&#039;)) {
if ($count &gt; 2) {
throw new \InvalidArgumentException(sprintf(&#039;Invalid argument $savePath \&#039;%s\&#039;&#039;, $savePath));
}
$baseDir = ltrim(strrchr($savePath,&#039;;&#039;),&#039;;&#039;);
}
if ($baseDir &amp;&amp; !is_dir($baseDir)) {
mkdir($baseDir, 0777, true);
}
ini_set(&#039;session.save_path&#039;, $savePath);
ini_set(&#039;session.save_handler&#039;,&#039;files&#039;);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Proxy
{
abstract class AbstractProxy
{
protected $wrapper = false;
protected $active = false;
protected $saveHandlerName;
public function getSaveHandlerName()
{
return $this-&gt;saveHandlerName;
}
public function isSessionHandlerInterface()
{
return ($this instanceof \SessionHandlerInterface);
}
public function isWrapper()
{
return $this-&gt;wrapper;
}
public function isActive()
{
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return $this-&gt;active = \PHP_SESSION_ACTIVE === session_status();
}
return $this-&gt;active;
}
public function setActive($flag)
{
if (version_compare(phpversion(),&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
throw new \LogicException(&#039;This method is disabled in PHP 5.4.0+&#039;);
}
$this-&gt;active = (bool) $flag;
}
public function getId()
{
return session_id();
}
public function setId($id)
{
if ($this-&gt;isActive()) {
throw new \LogicException(&#039;Cannot change the ID of an active session&#039;);
}
session_id($id);
}
public function getName()
{
return session_name();
}
public function setName($name)
{
if ($this-&gt;isActive()) {
throw new \LogicException(&#039;Cannot change the name of an active session&#039;);
}
session_name($name);
}
}
}
namespace Symfony\Component\HttpFoundation\Session\Storage\Proxy
{
class SessionHandlerProxy extends AbstractProxy implements \SessionHandlerInterface
{
protected $handler;
public function __construct(\SessionHandlerInterface $handler)
{
$this-&gt;handler = $handler;
$this-&gt;wrapper = ($handler instanceof \SessionHandler);
$this-&gt;saveHandlerName = $this-&gt;wrapper ? ini_get(&#039;session.save_handler&#039;) :&#039;user&#039;;
}
public function open($savePath, $sessionName)
{
$return = (bool) $this-&gt;handler-&gt;open($savePath, $sessionName);
if (true === $return) {
$this-&gt;active = true;
}
return $return;
}
public function close()
{
$this-&gt;active = false;
return (bool) $this-&gt;handler-&gt;close();
}
public function read($id)
{
return (string) $this-&gt;handler-&gt;read($id);
}
public function write($id, $data)
{
return (bool) $this-&gt;handler-&gt;write($id, $data);
}
public function destroy($id)
{
return (bool) $this-&gt;handler-&gt;destroy($id);
}
public function gc($maxlifetime)
{
return (bool) $this-&gt;handler-&gt;gc($maxlifetime);
}
}
}
namespace Symfony\Component\HttpFoundation\Session
{
use Symfony\Component\HttpFoundation\Session\Storage\MetadataBag;
interface SessionInterface
{
public function start();
public function getId();
public function setId($id);
public function getName();
public function setName($name);
public function invalidate($lifetime = null);
public function migrate($destroy = false, $lifetime = null);
public function save();
public function has($name);
public function get($name, $default = null);
public function set($name, $value);
public function all();
public function replace(array $attributes);
public function remove($name);
public function clear();
public function isStarted();
public function registerBag(SessionBagInterface $bag);
public function getBag($name);
public function getMetadataBag();
}
}
namespace Symfony\Component\HttpFoundation\Session
{
use Symfony\Component\HttpFoundation\Session\Storage\SessionStorageInterface;
use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBag;
use Symfony\Component\HttpFoundation\Session\Attribute\AttributeBagInterface;
use Symfony\Component\HttpFoundation\Session\Flash\FlashBag;
use Symfony\Component\HttpFoundation\Session\Flash\FlashBagInterface;
use Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage;
class Session implements SessionInterface, \IteratorAggregate, \Countable
{
protected $storage;
private $flashName;
private $attributeName;
public function __construct(SessionStorageInterface $storage = null, AttributeBagInterface $attributes = null, FlashBagInterface $flashes = null)
{
$this-&gt;storage = $storage ?: new NativeSessionStorage();
$attributes = $attributes ?: new AttributeBag();
$this-&gt;attributeName = $attributes-&gt;getName();
$this-&gt;registerBag($attributes);
$flashes = $flashes ?: new FlashBag();
$this-&gt;flashName = $flashes-&gt;getName();
$this-&gt;registerBag($flashes);
}
public function start()
{
return $this-&gt;storage-&gt;start();
}
public function has($name)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;has($name);
}
public function get($name, $default = null)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;get($name, $default);
}
public function set($name, $value)
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;set($name, $value);
}
public function all()
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all();
}
public function replace(array $attributes)
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;replace($attributes);
}
public function remove($name)
{
return $this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;remove($name);
}
public function clear()
{
$this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;clear();
}
public function isStarted()
{
return $this-&gt;storage-&gt;isStarted();
}
public function getIterator()
{
return new \ArrayIterator($this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all());
}
public function count()
{
return count($this-&gt;storage-&gt;getBag($this-&gt;attributeName)-&gt;all());
}
public function invalidate($lifetime = null)
{
$this-&gt;storage-&gt;clear();
return $this-&gt;migrate(true, $lifetime);
}
public function migrate($destroy = false, $lifetime = null)
{
return $this-&gt;storage-&gt;regenerate($destroy, $lifetime);
}
public function save()
{
$this-&gt;storage-&gt;save();
}
public function getId()
{
return $this-&gt;storage-&gt;getId();
}
public function setId($id)
{
$this-&gt;storage-&gt;setId($id);
}
public function getName()
{
return $this-&gt;storage-&gt;getName();
}
public function setName($name)
{
$this-&gt;storage-&gt;setName($name);
}
public function getMetadataBag()
{
return $this-&gt;storage-&gt;getMetadataBag();
}
public function registerBag(SessionBagInterface $bag)
{
$this-&gt;storage-&gt;registerBag($bag);
}
public function getBag($name)
{
return $this-&gt;storage-&gt;getBag($name);
}
public function getFlashBag()
{
return $this-&gt;getBag($this-&gt;flashName);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\HttpFoundation\Session\Session;
use Symfony\Component\Security\Core\SecurityContext;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\HttpFoundation\Request;
class GlobalVariables
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function getSecurity()
{
if ($this-&gt;container-&gt;has(&#039;security.context&#039;)) {
return $this-&gt;container-&gt;get(&#039;security.context&#039;);
}
}
public function getUser()
{
if (!$security = $this-&gt;getSecurity()) {
return;
}
if (!$token = $security-&gt;getToken()) {
return;
}
$user = $token-&gt;getUser();
if (!is_object($user)) {
return;
}
return $user;
}
public function getRequest()
{
if ($this-&gt;container-&gt;has(&#039;request_stack&#039;)) {
return $this-&gt;container-&gt;get(&#039;request_stack&#039;)-&gt;getCurrentRequest();
}
}
public function getSession()
{
if ($request = $this-&gt;getRequest()) {
return $request-&gt;getSession();
}
}
public function getEnvironment()
{
return $this-&gt;container-&gt;getParameter(&#039;kernel.environment&#039;);
}
public function getDebug()
{
return (Boolean) $this-&gt;container-&gt;getParameter(&#039;kernel.debug&#039;);
}
}
}
namespace Symfony\Component\Templating
{
interface TemplateReferenceInterface
{
public function all();
public function set($name, $value);
public function get($name);
public function getPath();
public function getLogicalName();
public function __toString();
}
}
namespace Symfony\Component\Templating
{
class TemplateReference implements TemplateReferenceInterface
{
protected $parameters;
public function __construct($name = null, $engine = null)
{
$this-&gt;parameters = array(&#039;name&#039;=&gt; $name,&#039;engine&#039;=&gt; $engine,
);
}
public function __toString()
{
return $this-&gt;getLogicalName();
}
public function set($name, $value)
{
if (array_key_exists($name, $this-&gt;parameters)) {
$this-&gt;parameters[$name] = $value;
} else {
throw new \InvalidArgumentException(sprintf(&#039;The template does not support the &quot;%s&quot; parameter.&#039;, $name));
}
return $this;
}
public function get($name)
{
if (array_key_exists($name, $this-&gt;parameters)) {
return $this-&gt;parameters[$name];
}
throw new \InvalidArgumentException(sprintf(&#039;The template does not support the &quot;%s&quot; parameter.&#039;, $name));
}
public function all()
{
return $this-&gt;parameters;
}
public function getPath()
{
return $this-&gt;parameters[&#039;name&#039;];
}
public function getLogicalName()
{
return $this-&gt;parameters[&#039;name&#039;];
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\Templating\TemplateReference as BaseTemplateReference;
class TemplateReference extends BaseTemplateReference
{
public function __construct($bundle = null, $controller = null, $name = null, $format = null, $engine = null)
{
$this-&gt;parameters = array(&#039;bundle&#039;=&gt; $bundle,&#039;controller&#039;=&gt; $controller,&#039;name&#039;=&gt; $name,&#039;format&#039;=&gt; $format,&#039;engine&#039;=&gt; $engine,
);
}
public function getPath()
{
$controller = str_replace(&#039;\\&#039;,&#039;/&#039;, $this-&gt;get(&#039;controller&#039;));
$path = (empty($controller) ?&#039;&#039;: $controller.&#039;/&#039;).$this-&gt;get(&#039;name&#039;).&#039;.&#039;.$this-&gt;get(&#039;format&#039;).&#039;.&#039;.$this-&gt;get(&#039;engine&#039;);
return empty($this-&gt;parameters[&#039;bundle&#039;]) ?&#039;views/&#039;.$path :&#039;@&#039;.$this-&gt;get(&#039;bundle&#039;).&#039;/Resources/views/&#039;.$path;
}
public function getLogicalName()
{
return sprintf(&#039;%s:%s:%s.%s.%s&#039;, $this-&gt;parameters[&#039;bundle&#039;], $this-&gt;parameters[&#039;controller&#039;], $this-&gt;parameters[&#039;name&#039;], $this-&gt;parameters[&#039;format&#039;], $this-&gt;parameters[&#039;engine&#039;]);
}
}
}
namespace Symfony\Component\Templating
{
interface TemplateNameParserInterface
{
public function parse($name);
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating
{
use Symfony\Component\Templating\TemplateNameParserInterface;
use Symfony\Component\Templating\TemplateReferenceInterface;
use Symfony\Component\HttpKernel\KernelInterface;
class TemplateNameParser implements TemplateNameParserInterface
{
protected $kernel;
protected $cache = array();
public function __construct(KernelInterface $kernel)
{
$this-&gt;kernel = $kernel;
}
public function parse($name)
{
if ($name instanceof TemplateReferenceInterface) {
return $name;
} elseif (isset($this-&gt;cache[$name])) {
return $this-&gt;cache[$name];
}
$name = str_replace(&#039;:/&#039;,&#039;:&#039;, preg_replace(&#039;#/{2,}#&#039;,&#039;/&#039;, strtr($name,&#039;\\&#039;,&#039;/&#039;)));
if (false !== strpos($name,&#039;..&#039;)) {
throw new \RuntimeException(sprintf(&#039;Template name &quot;%s&quot; contains invalid characters.&#039;, $name));
}
if (!preg_match(&#039;/^([^:]*):([^:]*):(.+)\.([^\.]+)\.([^\.]+)$/&#039;, $name, $matches)) {
throw new \InvalidArgumentException(sprintf(&#039;Template name &quot;%s&quot; is not valid (format is &quot;bundle:section:template.format.engine&quot;).&#039;, $name));
}
$template = new TemplateReference($matches[1], $matches[2], $matches[3], $matches[4], $matches[5]);
if ($template-&gt;get(&#039;bundle&#039;)) {
try {
$this-&gt;kernel-&gt;getBundle($template-&gt;get(&#039;bundle&#039;));
} catch (\Exception $e) {
throw new \InvalidArgumentException(sprintf(&#039;Template name &quot;%s&quot; is not valid.&#039;, $name), 0, $e);
}
}
return $this-&gt;cache[$name] = $template;
}
}
}
namespace Symfony\Component\Config
{
interface FileLocatorInterface
{
public function locate($name, $currentPath = null, $first = true);
}
}
namespace Symfony\Bundle\FrameworkBundle\Templating\Loader
{
use Symfony\Component\Config\FileLocatorInterface;
use Symfony\Component\Templating\TemplateReferenceInterface;
class TemplateLocator implements FileLocatorInterface
{
protected $locator;
protected $cache;
public function __construct(FileLocatorInterface $locator, $cacheDir = null)
{
if (null !== $cacheDir &amp;&amp; is_file($cache = $cacheDir.&#039;/templates.php&#039;)) {
$this-&gt;cache = require $cache;
}
$this-&gt;locator = $locator;
}
protected function getCacheKey($template)
{
return $template-&gt;getLogicalName();
}
public function locate($template, $currentPath = null, $first = true)
{
if (!$template instanceof TemplateReferenceInterface) {
throw new \InvalidArgumentException(&#039;The template must be an instance of TemplateReferenceInterface.&#039;);
}
$key = $this-&gt;getCacheKey($template);
if (isset($this-&gt;cache[$key])) {
return $this-&gt;cache[$key];
}
try {
return $this-&gt;cache[$key] = $this-&gt;locator-&gt;locate($template-&gt;getPath(), $currentPath);
} catch (\InvalidArgumentException $e) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to find template &quot;%s&quot; : &quot;%s&quot;.&#039;, $template, $e-&gt;getMessage()), 0, $e);
}
}
}
}
namespace Symfony\Component\Routing
{
interface RequestContextAwareInterface
{
public function setContext(RequestContext $context);
public function getContext();
}
}
namespace Symfony\Component\Routing\Generator
{
use Symfony\Component\Routing\Exception\InvalidParameterException;
use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
use Symfony\Component\Routing\Exception\RouteNotFoundException;
use Symfony\Component\Routing\RequestContextAwareInterface;
interface UrlGeneratorInterface extends RequestContextAwareInterface
{
const ABSOLUTE_URL = true;
const ABSOLUTE_PATH = false;
const RELATIVE_PATH =&#039;relative&#039;;
const NETWORK_PATH =&#039;network&#039;;
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH);
}
}
namespace Symfony\Component\Routing\Generator
{
interface ConfigurableRequirementsInterface
{
public function setStrictRequirements($enabled);
public function isStrictRequirements();
}
}
namespace Symfony\Component\Routing\Generator
{
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Exception\InvalidParameterException;
use Symfony\Component\Routing\Exception\RouteNotFoundException;
use Symfony\Component\Routing\Exception\MissingMandatoryParametersException;
use Psr\Log\LoggerInterface;
class UrlGenerator implements UrlGeneratorInterface, ConfigurableRequirementsInterface
{
protected $routes;
protected $context;
protected $strictRequirements = true;
protected $logger;
protected $decodedChars = array(&#039;%2F&#039;=&gt;&#039;/&#039;,&#039;%40&#039;=&gt;&#039;@&#039;,&#039;%3A&#039;=&gt;&#039;:&#039;,&#039;%3B&#039;=&gt;&#039;;&#039;,&#039;%2C&#039;=&gt;&#039;,&#039;,&#039;%3D&#039;=&gt;&#039;=&#039;,&#039;%2B&#039;=&gt;&#039;+&#039;,&#039;%21&#039;=&gt;&#039;!&#039;,&#039;%2A&#039;=&gt;&#039;*&#039;,&#039;%7C&#039;=&gt;&#039;|&#039;,
);
public function __construct(RouteCollection $routes, RequestContext $context, LoggerInterface $logger = null)
{
$this-&gt;routes = $routes;
$this-&gt;context = $context;
$this-&gt;logger = $logger;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
}
public function getContext()
{
return $this-&gt;context;
}
public function setStrictRequirements($enabled)
{
$this-&gt;strictRequirements = null === $enabled ? null : (Boolean) $enabled;
}
public function isStrictRequirements()
{
return $this-&gt;strictRequirements;
}
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
{
if (null === $route = $this-&gt;routes-&gt;get($name)) {
throw new RouteNotFoundException(sprintf(&#039;Unable to generate a URL for the named route &quot;%s&quot; as such route does not exist.&#039;, $name));
}
$compiledRoute = $route-&gt;compile();
return $this-&gt;doGenerate($compiledRoute-&gt;getVariables(), $route-&gt;getDefaults(), $route-&gt;getRequirements(), $compiledRoute-&gt;getTokens(), $parameters, $name, $referenceType, $compiledRoute-&gt;getHostTokens());
}
protected function doGenerate($variables, $defaults, $requirements, $tokens, $parameters, $name, $referenceType, $hostTokens)
{
$variables = array_flip($variables);
$mergedParams = array_replace($defaults, $this-&gt;context-&gt;getParameters(), $parameters);
if ($diff = array_diff_key($variables, $mergedParams)) {
throw new MissingMandatoryParametersException(sprintf(&#039;Some mandatory parameters are missing (&quot;%s&quot;) to generate a URL for route &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, array_keys($diff)), $name));
}
$url =&#039;&#039;;
$optional = true;
foreach ($tokens as $token) {
if (&#039;variable&#039;=== $token[0]) {
if (!$optional || !array_key_exists($token[3], $defaults) || null !== $mergedParams[$token[3]] &amp;&amp; (string) $mergedParams[$token[3]] !== (string) $defaults[$token[3]]) {
if (null !== $this-&gt;strictRequirements &amp;&amp; !preg_match(&#039;#^&#039;.$token[2].&#039;$#&#039;, $mergedParams[$token[3]])) {
$message = sprintf(&#039;Parameter &quot;%s&quot; for route &quot;%s&quot; must match &quot;%s&quot; (&quot;%s&quot; given) to generate a corresponding URL.&#039;, $token[3], $name, $token[2], $mergedParams[$token[3]]);
if ($this-&gt;strictRequirements) {
throw new InvalidParameterException($message);
}
if ($this-&gt;logger) {
$this-&gt;logger-&gt;error($message);
}
return null;
}
$url = $token[1].$mergedParams[$token[3]].$url;
$optional = false;
}
} else {
$url = $token[1].$url;
$optional = false;
}
}
if (&#039;&#039;=== $url) {
$url =&#039;/&#039;;
}
$url = strtr(rawurlencode($url), $this-&gt;decodedChars);
$url = strtr($url, array(&#039;/../&#039;=&gt;&#039;/%2E%2E/&#039;,&#039;/./&#039;=&gt;&#039;/%2E/&#039;));
if (&#039;/..&#039;=== substr($url, -3)) {
$url = substr($url, 0, -2).&#039;%2E%2E&#039;;
} elseif (&#039;/.&#039;=== substr($url, -2)) {
$url = substr($url, 0, -1).&#039;%2E&#039;;
}
$schemeAuthority =&#039;&#039;;
if ($host = $this-&gt;context-&gt;getHost()) {
$scheme = $this-&gt;context-&gt;getScheme();
if (isset($requirements[&#039;_scheme&#039;]) &amp;&amp; ($req = strtolower($requirements[&#039;_scheme&#039;])) &amp;&amp; $scheme !== $req) {
$referenceType = self::ABSOLUTE_URL;
$scheme = $req;
}
if ($hostTokens) {
$routeHost =&#039;&#039;;
foreach ($hostTokens as $token) {
if (&#039;variable&#039;=== $token[0]) {
if (null !== $this-&gt;strictRequirements &amp;&amp; !preg_match(&#039;#^&#039;.$token[2].&#039;$#&#039;, $mergedParams[$token[3]])) {
$message = sprintf(&#039;Parameter &quot;%s&quot; for route &quot;%s&quot; must match &quot;%s&quot; (&quot;%s&quot; given) to generate a corresponding URL.&#039;, $token[3], $name, $token[2], $mergedParams[$token[3]]);
if ($this-&gt;strictRequirements) {
throw new InvalidParameterException($message);
}
if ($this-&gt;logger) {
$this-&gt;logger-&gt;error($message);
}
return null;
}
$routeHost = $token[1].$mergedParams[$token[3]].$routeHost;
} else {
$routeHost = $token[1].$routeHost;
}
}
if ($routeHost !== $host) {
$host = $routeHost;
if (self::ABSOLUTE_URL !== $referenceType) {
$referenceType = self::NETWORK_PATH;
}
}
}
if (self::ABSOLUTE_URL === $referenceType || self::NETWORK_PATH === $referenceType) {
$port =&#039;&#039;;
if (&#039;http&#039;=== $scheme &amp;&amp; 80 != $this-&gt;context-&gt;getHttpPort()) {
$port =&#039;:&#039;.$this-&gt;context-&gt;getHttpPort();
} elseif (&#039;https&#039;=== $scheme &amp;&amp; 443 != $this-&gt;context-&gt;getHttpsPort()) {
$port =&#039;:&#039;.$this-&gt;context-&gt;getHttpsPort();
}
$schemeAuthority = self::NETWORK_PATH === $referenceType ?&#039;//&#039;: &quot;$scheme://&quot;;
$schemeAuthority .= $host.$port;
}
}
if (self::RELATIVE_PATH === $referenceType) {
$url = self::getRelativePath($this-&gt;context-&gt;getPathInfo(), $url);
} else {
$url = $schemeAuthority.$this-&gt;context-&gt;getBaseUrl().$url;
}
$extra = array_diff_key($parameters, $variables, $defaults);
if ($extra &amp;&amp; $query = http_build_query($extra,&#039;&#039;,&#039;&amp;&#039;)) {
$url .=&#039;?&#039;.$query;
}
return $url;
}
public static function getRelativePath($basePath, $targetPath)
{
if ($basePath === $targetPath) {
return&#039;&#039;;
}
$sourceDirs = explode(&#039;/&#039;, isset($basePath[0]) &amp;&amp;&#039;/&#039;=== $basePath[0] ? substr($basePath, 1) : $basePath);
$targetDirs = explode(&#039;/&#039;, isset($targetPath[0]) &amp;&amp;&#039;/&#039;=== $targetPath[0] ? substr($targetPath, 1) : $targetPath);
array_pop($sourceDirs);
$targetFile = array_pop($targetDirs);
foreach ($sourceDirs as $i =&gt; $dir) {
if (isset($targetDirs[$i]) &amp;&amp; $dir === $targetDirs[$i]) {
unset($sourceDirs[$i], $targetDirs[$i]);
} else {
break;
}
}
$targetDirs[] = $targetFile;
$path = str_repeat(&#039;../&#039;, count($sourceDirs)).implode(&#039;/&#039;, $targetDirs);
return&#039;&#039;=== $path ||&#039;/&#039;=== $path[0]
|| false !== ($colonPos = strpos($path,&#039;:&#039;)) &amp;&amp; ($colonPos &lt; ($slashPos = strpos($path,&#039;/&#039;)) || false === $slashPos)
? &quot;./$path&quot; : $path;
}
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\HttpFoundation\Request;
class RequestContext
{
private $baseUrl;
private $pathInfo;
private $method;
private $host;
private $scheme;
private $httpPort;
private $httpsPort;
private $queryString;
private $parameters = array();
public function __construct($baseUrl =&#039;&#039;, $method =&#039;GET&#039;, $host =&#039;localhost&#039;, $scheme =&#039;http&#039;, $httpPort = 80, $httpsPort = 443, $path =&#039;/&#039;, $queryString =&#039;&#039;)
{
$this-&gt;baseUrl = $baseUrl;
$this-&gt;method = strtoupper($method);
$this-&gt;host = $host;
$this-&gt;scheme = strtolower($scheme);
$this-&gt;httpPort = $httpPort;
$this-&gt;httpsPort = $httpsPort;
$this-&gt;pathInfo = $path;
$this-&gt;queryString = $queryString;
}
public function fromRequest(Request $request)
{
$this-&gt;setBaseUrl($request-&gt;getBaseUrl());
$this-&gt;setPathInfo($request-&gt;getPathInfo());
$this-&gt;setMethod($request-&gt;getMethod());
$this-&gt;setHost($request-&gt;getHost());
$this-&gt;setScheme($request-&gt;getScheme());
$this-&gt;setHttpPort($request-&gt;isSecure() ? $this-&gt;httpPort : $request-&gt;getPort());
$this-&gt;setHttpsPort($request-&gt;isSecure() ? $request-&gt;getPort() : $this-&gt;httpsPort);
$this-&gt;setQueryString($request-&gt;server-&gt;get(&#039;QUERY_STRING&#039;));
}
public function getBaseUrl()
{
return $this-&gt;baseUrl;
}
public function setBaseUrl($baseUrl)
{
$this-&gt;baseUrl = $baseUrl;
}
public function getPathInfo()
{
return $this-&gt;pathInfo;
}
public function setPathInfo($pathInfo)
{
$this-&gt;pathInfo = $pathInfo;
}
public function getMethod()
{
return $this-&gt;method;
}
public function setMethod($method)
{
$this-&gt;method = strtoupper($method);
}
public function getHost()
{
return $this-&gt;host;
}
public function setHost($host)
{
$this-&gt;host = $host;
}
public function getScheme()
{
return $this-&gt;scheme;
}
public function setScheme($scheme)
{
$this-&gt;scheme = strtolower($scheme);
}
public function getHttpPort()
{
return $this-&gt;httpPort;
}
public function setHttpPort($httpPort)
{
$this-&gt;httpPort = $httpPort;
}
public function getHttpsPort()
{
return $this-&gt;httpsPort;
}
public function setHttpsPort($httpsPort)
{
$this-&gt;httpsPort = $httpsPort;
}
public function getQueryString()
{
return $this-&gt;queryString;
}
public function setQueryString($queryString)
{
$this-&gt;queryString = $queryString;
}
public function getParameters()
{
return $this-&gt;parameters;
}
public function setParameters(array $parameters)
{
$this-&gt;parameters = $parameters;
return $this;
}
public function getParameter($name)
{
return isset($this-&gt;parameters[$name]) ? $this-&gt;parameters[$name] : null;
}
public function hasParameter($name)
{
return array_key_exists($name, $this-&gt;parameters);
}
public function setParameter($name, $parameter)
{
$this-&gt;parameters[$name] = $parameter;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\RequestContextAwareInterface;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
interface UrlMatcherInterface extends RequestContextAwareInterface
{
public function match($pathinfo);
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
interface RouterInterface extends UrlMatcherInterface, UrlGeneratorInterface
{
public function getRouteCollection();
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
interface RequestMatcherInterface
{
public function matchRequest(Request $request);
}
}
namespace Symfony\Component\Routing
{
use Symfony\Component\Config\Loader\LoaderInterface;
use Symfony\Component\Config\ConfigCache;
use Psr\Log\LoggerInterface;
use Symfony\Component\Routing\Generator\ConfigurableRequirementsInterface;
use Symfony\Component\Routing\Generator\UrlGeneratorInterface;
use Symfony\Component\Routing\Generator\Dumper\GeneratorDumperInterface;
use Symfony\Component\Routing\Matcher\RequestMatcherInterface;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
use Symfony\Component\Routing\Matcher\Dumper\MatcherDumperInterface;
use Symfony\Component\HttpFoundation\Request;
class Router implements RouterInterface, RequestMatcherInterface
{
protected $matcher;
protected $generator;
protected $context;
protected $loader;
protected $collection;
protected $resource;
protected $options = array();
protected $logger;
public function __construct(LoaderInterface $loader, $resource, array $options = array(), RequestContext $context = null, LoggerInterface $logger = null)
{
$this-&gt;loader = $loader;
$this-&gt;resource = $resource;
$this-&gt;logger = $logger;
$this-&gt;context = $context ?: new RequestContext();
$this-&gt;setOptions($options);
}
public function setOptions(array $options)
{
$this-&gt;options = array(&#039;cache_dir&#039;=&gt; null,&#039;debug&#039;=&gt; false,&#039;generator_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\UrlGenerator&#039;,&#039;generator_base_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\UrlGenerator&#039;,&#039;generator_dumper_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Generator\\Dumper\\PhpGeneratorDumper&#039;,&#039;generator_cache_class&#039;=&gt;&#039;ProjectUrlGenerator&#039;,&#039;matcher_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\UrlMatcher&#039;,&#039;matcher_base_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\UrlMatcher&#039;,&#039;matcher_dumper_class&#039;=&gt;&#039;Symfony\\Component\\Routing\\Matcher\\Dumper\\PhpMatcherDumper&#039;,&#039;matcher_cache_class&#039;=&gt;&#039;ProjectUrlMatcher&#039;,&#039;resource_type&#039;=&gt; null,&#039;strict_requirements&#039;=&gt; true,
);
$invalid = array();
foreach ($options as $key =&gt; $value) {
if (array_key_exists($key, $this-&gt;options)) {
$this-&gt;options[$key] = $value;
} else {
$invalid[] = $key;
}
}
if ($invalid) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the following options: &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, $invalid)));
}
}
public function setOption($key, $value)
{
if (!array_key_exists($key, $this-&gt;options)) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the &quot;%s&quot; option.&#039;, $key));
}
$this-&gt;options[$key] = $value;
}
public function getOption($key)
{
if (!array_key_exists($key, $this-&gt;options)) {
throw new \InvalidArgumentException(sprintf(&#039;The Router does not support the &quot;%s&quot; option.&#039;, $key));
}
return $this-&gt;options[$key];
}
public function getRouteCollection()
{
if (null === $this-&gt;collection) {
$this-&gt;collection = $this-&gt;loader-&gt;load($this-&gt;resource, $this-&gt;options[&#039;resource_type&#039;]);
}
return $this-&gt;collection;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
if (null !== $this-&gt;matcher) {
$this-&gt;getMatcher()-&gt;setContext($context);
}
if (null !== $this-&gt;generator) {
$this-&gt;getGenerator()-&gt;setContext($context);
}
}
public function getContext()
{
return $this-&gt;context;
}
public function generate($name, $parameters = array(), $referenceType = self::ABSOLUTE_PATH)
{
return $this-&gt;getGenerator()-&gt;generate($name, $parameters, $referenceType);
}
public function match($pathinfo)
{
return $this-&gt;getMatcher()-&gt;match($pathinfo);
}
public function matchRequest(Request $request)
{
$matcher = $this-&gt;getMatcher();
if (!$matcher instanceof RequestMatcherInterface) {
return $matcher-&gt;match($request-&gt;getPathInfo());
}
return $matcher-&gt;matchRequest($request);
}
public function getMatcher()
{
if (null !== $this-&gt;matcher) {
return $this-&gt;matcher;
}
if (null === $this-&gt;options[&#039;cache_dir&#039;] || null === $this-&gt;options[&#039;matcher_cache_class&#039;]) {
return $this-&gt;matcher = new $this-&gt;options[&#039;matcher_class&#039;]($this-&gt;getRouteCollection(), $this-&gt;context);
}
$class = $this-&gt;options[&#039;matcher_cache_class&#039;];
$cache = new ConfigCache($this-&gt;options[&#039;cache_dir&#039;].&#039;/&#039;.$class.&#039;.php&#039;, $this-&gt;options[&#039;debug&#039;]);
if (!$cache-&gt;isFresh()) {
$dumper = $this-&gt;getMatcherDumperInstance();
$options = array(&#039;class&#039;=&gt; $class,&#039;base_class&#039;=&gt; $this-&gt;options[&#039;matcher_base_class&#039;],
);
$cache-&gt;write($dumper-&gt;dump($options), $this-&gt;getRouteCollection()-&gt;getResources());
}
require_once $cache;
return $this-&gt;matcher = new $class($this-&gt;context);
}
public function getGenerator()
{
if (null !== $this-&gt;generator) {
return $this-&gt;generator;
}
if (null === $this-&gt;options[&#039;cache_dir&#039;] || null === $this-&gt;options[&#039;generator_cache_class&#039;]) {
$this-&gt;generator = new $this-&gt;options[&#039;generator_class&#039;]($this-&gt;getRouteCollection(), $this-&gt;context, $this-&gt;logger);
} else {
$class = $this-&gt;options[&#039;generator_cache_class&#039;];
$cache = new ConfigCache($this-&gt;options[&#039;cache_dir&#039;].&#039;/&#039;.$class.&#039;.php&#039;, $this-&gt;options[&#039;debug&#039;]);
if (!$cache-&gt;isFresh()) {
$dumper = $this-&gt;getGeneratorDumperInstance();
$options = array(&#039;class&#039;=&gt; $class,&#039;base_class&#039;=&gt; $this-&gt;options[&#039;generator_base_class&#039;],
);
$cache-&gt;write($dumper-&gt;dump($options), $this-&gt;getRouteCollection()-&gt;getResources());
}
require_once $cache;
$this-&gt;generator = new $class($this-&gt;context, $this-&gt;logger);
}
if ($this-&gt;generator instanceof ConfigurableRequirementsInterface) {
$this-&gt;generator-&gt;setStrictRequirements($this-&gt;options[&#039;strict_requirements&#039;]);
}
return $this-&gt;generator;
}
protected function getGeneratorDumperInstance()
{
return new $this-&gt;options[&#039;generator_dumper_class&#039;]($this-&gt;getRouteCollection());
}
protected function getMatcherDumperInstance()
{
return new $this-&gt;options[&#039;matcher_dumper_class&#039;]($this-&gt;getRouteCollection());
}
}
}
namespace Symfony\Component\Routing\Matcher
{
interface RedirectableUrlMatcherInterface
{
public function redirect($path, $route, $scheme = null);
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\Route;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
class UrlMatcher implements UrlMatcherInterface, RequestMatcherInterface
{
const REQUIREMENT_MATCH = 0;
const REQUIREMENT_MISMATCH = 1;
const ROUTE_MATCH = 2;
protected $context;
protected $allow = array();
protected $routes;
protected $request;
protected $expressionLanguage;
public function __construct(RouteCollection $routes, RequestContext $context)
{
$this-&gt;routes = $routes;
$this-&gt;context = $context;
}
public function setContext(RequestContext $context)
{
$this-&gt;context = $context;
}
public function getContext()
{
return $this-&gt;context;
}
public function match($pathinfo)
{
$this-&gt;allow = array();
if ($ret = $this-&gt;matchCollection(rawurldecode($pathinfo), $this-&gt;routes)) {
return $ret;
}
throw 0 &lt; count($this-&gt;allow)
? new MethodNotAllowedException(array_unique(array_map(&#039;strtoupper&#039;, $this-&gt;allow)))
: new ResourceNotFoundException();
}
public function matchRequest(Request $request)
{
$this-&gt;request = $request;
$ret = $this-&gt;match($request-&gt;getPathInfo());
$this-&gt;request = null;
return $ret;
}
protected function matchCollection($pathinfo, RouteCollection $routes)
{
foreach ($routes as $name =&gt; $route) {
$compiledRoute = $route-&gt;compile();
if (&#039;&#039;!== $compiledRoute-&gt;getStaticPrefix() &amp;&amp; 0 !== strpos($pathinfo, $compiledRoute-&gt;getStaticPrefix())) {
continue;
}
if (!preg_match($compiledRoute-&gt;getRegex(), $pathinfo, $matches)) {
continue;
}
$hostMatches = array();
if ($compiledRoute-&gt;getHostRegex() &amp;&amp; !preg_match($compiledRoute-&gt;getHostRegex(), $this-&gt;context-&gt;getHost(), $hostMatches)) {
continue;
}
if ($req = $route-&gt;getRequirement(&#039;_method&#039;)) {
if (&#039;HEAD&#039;=== $method = $this-&gt;context-&gt;getMethod()) {
$method =&#039;GET&#039;;
}
if (!in_array($method, $req = explode(&#039;|&#039;, strtoupper($req)))) {
$this-&gt;allow = array_merge($this-&gt;allow, $req);
continue;
}
}
$status = $this-&gt;handleRouteRequirements($pathinfo, $name, $route);
if (self::ROUTE_MATCH === $status[0]) {
return $status[1];
}
if (self::REQUIREMENT_MISMATCH === $status[0]) {
continue;
}
return $this-&gt;getAttributes($route, $name, array_replace($matches, $hostMatches));
}
}
protected function getAttributes(Route $route, $name, array $attributes)
{
$attributes[&#039;_route&#039;] = $name;
return $this-&gt;mergeDefaults($attributes, $route-&gt;getDefaults());
}
protected function handleRouteRequirements($pathinfo, $name, Route $route)
{
if ($route-&gt;getCondition() &amp;&amp; !$this-&gt;getExpressionLanguage()-&gt;evaluate($route-&gt;getCondition(), array(&#039;context&#039;=&gt; $this-&gt;context,&#039;request&#039;=&gt; $this-&gt;request))) {
return array(self::REQUIREMENT_MISMATCH, null);
}
$scheme = $route-&gt;getRequirement(&#039;_scheme&#039;);
$status = $scheme &amp;&amp; $scheme !== $this-&gt;context-&gt;getScheme() ? self::REQUIREMENT_MISMATCH : self::REQUIREMENT_MATCH;
return array($status, null);
}
protected function mergeDefaults($params, $defaults)
{
foreach ($params as $key =&gt; $value) {
if (!is_int($key)) {
$defaults[$key] = $value;
}
}
return $defaults;
}
protected function getExpressionLanguage()
{
if (null === $this-&gt;expressionLanguage) {
if (!class_exists(&#039;Symfony\Component\ExpressionLanguage\ExpressionLanguage&#039;)) {
throw new \RuntimeException(&#039;Unable to use expressions as the Symfony ExpressionLanguage component is not installed.&#039;);
}
$this-&gt;expressionLanguage = new ExpressionLanguage();
}
return $this-&gt;expressionLanguage;
}
}
}
namespace Symfony\Component\Routing\Matcher
{
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Route;
abstract class RedirectableUrlMatcher extends UrlMatcher implements RedirectableUrlMatcherInterface
{
public function match($pathinfo)
{
try {
$parameters = parent::match($pathinfo);
} catch (ResourceNotFoundException $e) {
if (&#039;/&#039;=== substr($pathinfo, -1) || !in_array($this-&gt;context-&gt;getMethod(), array(&#039;HEAD&#039;,&#039;GET&#039;))) {
throw $e;
}
try {
parent::match($pathinfo.&#039;/&#039;);
return $this-&gt;redirect($pathinfo.&#039;/&#039;, null);
} catch (ResourceNotFoundException $e2) {
throw $e;
}
}
return $parameters;
}
protected function handleRouteRequirements($pathinfo, $name, Route $route)
{
if ($route-&gt;getCondition() &amp;&amp; !$this-&gt;getExpressionLanguage()-&gt;evaluate($route-&gt;getCondition(), array(&#039;context&#039;=&gt; $this-&gt;context,&#039;request&#039;=&gt; $this-&gt;request))) {
return array(self::REQUIREMENT_MISMATCH, null);
}
$scheme = $route-&gt;getRequirement(&#039;_scheme&#039;);
if ($scheme &amp;&amp; $this-&gt;context-&gt;getScheme() !== $scheme) {
return array(self::ROUTE_MATCH, $this-&gt;redirect($pathinfo, $name, $scheme));
}
return array(self::REQUIREMENT_MATCH, null);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Routing
{
use Symfony\Component\Routing\Matcher\RedirectableUrlMatcher as BaseMatcher;
class RedirectableUrlMatcher extends BaseMatcher
{
public function redirect($path, $route, $scheme = null)
{
return array(&#039;_controller&#039;=&gt;&#039;Symfony\\Bundle\\FrameworkBundle\\Controller\\RedirectController::urlRedirectAction&#039;,&#039;path&#039;=&gt; $path,&#039;permanent&#039;=&gt; true,&#039;scheme&#039;=&gt; $scheme,&#039;httpPort&#039;=&gt; $this-&gt;context-&gt;getHttpPort(),&#039;httpsPort&#039;=&gt; $this-&gt;context-&gt;getHttpsPort(),&#039;_route&#039;=&gt; $route,
);
}
}
}
namespace Symfony\Component\HttpKernel\CacheWarmer
{
interface WarmableInterface
{
public function warmUp($cacheDir);
}
}
namespace Symfony\Bundle\FrameworkBundle\Routing
{
use Symfony\Component\Routing\Router as BaseRouter;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\Routing\RouteCollection;
use Symfony\Component\HttpKernel\CacheWarmer\WarmableInterface;
use Symfony\Component\DependencyInjection\Exception\ParameterNotFoundException;
use Symfony\Component\DependencyInjection\Exception\RuntimeException;
class Router extends BaseRouter implements WarmableInterface
{
private $container;
public function __construct(ContainerInterface $container, $resource, array $options = array(), RequestContext $context = null)
{
$this-&gt;container = $container;
$this-&gt;resource = $resource;
$this-&gt;context = $context ?: new RequestContext();
$this-&gt;setOptions($options);
}
public function getRouteCollection()
{
if (null === $this-&gt;collection) {
$this-&gt;collection = $this-&gt;container-&gt;get(&#039;routing.loader&#039;)-&gt;load($this-&gt;resource, $this-&gt;options[&#039;resource_type&#039;]);
$this-&gt;resolveParameters($this-&gt;collection);
}
return $this-&gt;collection;
}
public function warmUp($cacheDir)
{
$currentDir = $this-&gt;getOption(&#039;cache_dir&#039;);
$this-&gt;setOption(&#039;cache_dir&#039;, $cacheDir);
$this-&gt;getMatcher();
$this-&gt;getGenerator();
$this-&gt;setOption(&#039;cache_dir&#039;, $currentDir);
}
private function resolveParameters(RouteCollection $collection)
{
foreach ($collection as $route) {
foreach ($route-&gt;getDefaults() as $name =&gt; $value) {
$route-&gt;setDefault($name, $this-&gt;resolve($value));
}
foreach ($route-&gt;getRequirements() as $name =&gt; $value) {
$route-&gt;setRequirement($name, $this-&gt;resolve($value));
}
$route-&gt;setPath($this-&gt;resolve($route-&gt;getPath()));
$route-&gt;setHost($this-&gt;resolve($route-&gt;getHost()));
}
}
private function resolve($value)
{
if (is_array($value)) {
foreach ($value as $key =&gt; $val) {
$value[$key] = $this-&gt;resolve($val);
}
return $value;
}
if (!is_string($value)) {
return $value;
}
$container = $this-&gt;container;
$escapedValue = preg_replace_callback(&#039;/%%|%([^%\s]++)%/&#039;, function ($match) use ($container, $value) {
if (!isset($match[1])) {
return&#039;%%&#039;;
}
$resolved = $container-&gt;getParameter($match[1]);
if (is_string($resolved) || is_numeric($resolved)) {
return (string) $resolved;
}
throw new RuntimeException(sprintf(&#039;The container parameter &quot;%s&quot;, used in the route configuration value &quot;%s&quot;, &#039;.&#039;must be a string or numeric, but it is of type %s.&#039;,
$match[1],
$value,
gettype($resolved)
)
);
}, $value);
return str_replace(&#039;%%&#039;,&#039;%&#039;, $escapedValue);
}
}
}
namespace Symfony\Component\Config
{
class FileLocator implements FileLocatorInterface
{
protected $paths;
public function __construct($paths = array())
{
$this-&gt;paths = (array) $paths;
}
public function locate($name, $currentPath = null, $first = true)
{
if ($this-&gt;isAbsolutePath($name)) {
if (!file_exists($name)) {
throw new \InvalidArgumentException(sprintf(&#039;The file &quot;%s&quot; does not exist.&#039;, $name));
}
return $name;
}
$filepaths = array();
if (null !== $currentPath &amp;&amp; file_exists($file = $currentPath.DIRECTORY_SEPARATOR.$name)) {
if (true === $first) {
return $file;
}
$filepaths[] = $file;
}
foreach ($this-&gt;paths as $path) {
if (file_exists($file = $path.DIRECTORY_SEPARATOR.$name)) {
if (true === $first) {
return $file;
}
$filepaths[] = $file;
}
}
if (!$filepaths) {
throw new \InvalidArgumentException(sprintf(&#039;The file &quot;%s&quot; does not exist (in: %s%s).&#039;, $name, null !== $currentPath ? $currentPath.&#039;, &#039;:&#039;&#039;, implode(&#039;, &#039;, $this-&gt;paths)));
}
return array_values(array_unique($filepaths));
}
private function isAbsolutePath($file)
{
if ($file[0] ==&#039;/&#039;|| $file[0] ==&#039;\\&#039;|| (strlen($file) &gt; 3 &amp;&amp; ctype_alpha($file[0])
&amp;&amp; $file[1] ==&#039;:&#039;&amp;&amp; ($file[2] ==&#039;\\&#039;|| $file[2] ==&#039;/&#039;)
)
|| null !== parse_url($file, PHP_URL_SCHEME)
) {
return true;
}
return false;
}
}
}
namespace Symfony\Component\EventDispatcher
{
class Event
{
private $propagationStopped = false;
private $dispatcher;
private $name;
public function isPropagationStopped()
{
return $this-&gt;propagationStopped;
}
public function stopPropagation()
{
$this-&gt;propagationStopped = true;
}
public function setDispatcher(EventDispatcherInterface $dispatcher)
{
$this-&gt;dispatcher = $dispatcher;
}
public function getDispatcher()
{
return $this-&gt;dispatcher;
}
public function getName()
{
return $this-&gt;name;
}
public function setName($name)
{
$this-&gt;name = $name;
}
}
}
namespace Symfony\Component\EventDispatcher
{
interface EventDispatcherInterface
{
public function dispatch($eventName, Event $event = null);
public function addListener($eventName, $listener, $priority = 0);
public function addSubscriber(EventSubscriberInterface $subscriber);
public function removeListener($eventName, $listener);
public function removeSubscriber(EventSubscriberInterface $subscriber);
public function getListeners($eventName = null);
public function hasListeners($eventName = null);
}
}
namespace Symfony\Component\EventDispatcher
{
class EventDispatcher implements EventDispatcherInterface
{
private $listeners = array();
private $sorted = array();
public function dispatch($eventName, Event $event = null)
{
if (null === $event) {
$event = new Event();
}
$event-&gt;setDispatcher($this);
$event-&gt;setName($eventName);
if (!isset($this-&gt;listeners[$eventName])) {
return $event;
}
$this-&gt;doDispatch($this-&gt;getListeners($eventName), $eventName, $event);
return $event;
}
public function getListeners($eventName = null)
{
if (null !== $eventName) {
if (!isset($this-&gt;sorted[$eventName])) {
$this-&gt;sortListeners($eventName);
}
return $this-&gt;sorted[$eventName];
}
foreach (array_keys($this-&gt;listeners) as $eventName) {
if (!isset($this-&gt;sorted[$eventName])) {
$this-&gt;sortListeners($eventName);
}
}
return $this-&gt;sorted;
}
public function hasListeners($eventName = null)
{
return (Boolean) count($this-&gt;getListeners($eventName));
}
public function addListener($eventName, $listener, $priority = 0)
{
$this-&gt;listeners[$eventName][$priority][] = $listener;
unset($this-&gt;sorted[$eventName]);
}
public function removeListener($eventName, $listener)
{
if (!isset($this-&gt;listeners[$eventName])) {
return;
}
foreach ($this-&gt;listeners[$eventName] as $priority =&gt; $listeners) {
if (false !== ($key = array_search($listener, $listeners, true))) {
unset($this-&gt;listeners[$eventName][$priority][$key], $this-&gt;sorted[$eventName]);
}
}
}
public function addSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber-&gt;getSubscribedEvents() as $eventName =&gt; $params) {
if (is_string($params)) {
$this-&gt;addListener($eventName, array($subscriber, $params));
} elseif (is_string($params[0])) {
$this-&gt;addListener($eventName, array($subscriber, $params[0]), isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this-&gt;addListener($eventName, array($subscriber, $listener[0]), isset($listener[1]) ? $listener[1] : 0);
}
}
}
}
public function removeSubscriber(EventSubscriberInterface $subscriber)
{
foreach ($subscriber-&gt;getSubscribedEvents() as $eventName =&gt; $params) {
if (is_array($params) &amp;&amp; is_array($params[0])) {
foreach ($params as $listener) {
$this-&gt;removeListener($eventName, array($subscriber, $listener[0]));
}
} else {
$this-&gt;removeListener($eventName, array($subscriber, is_string($params) ? $params : $params[0]));
}
}
}
protected function doDispatch($listeners, $eventName, Event $event)
{
foreach ($listeners as $listener) {
call_user_func($listener, $event, $eventName, $this);
if ($event-&gt;isPropagationStopped()) {
break;
}
}
}
private function sortListeners($eventName)
{
$this-&gt;sorted[$eventName] = array();
if (isset($this-&gt;listeners[$eventName])) {
krsort($this-&gt;listeners[$eventName]);
$this-&gt;sorted[$eventName] = call_user_func_array(&#039;array_merge&#039;, $this-&gt;listeners[$eventName]);
}
}
}
}
namespace Symfony\Component\EventDispatcher
{
use Symfony\Component\DependencyInjection\ContainerInterface;
class ContainerAwareEventDispatcher extends EventDispatcher
{
private $container;
private $listenerIds = array();
private $listeners = array();
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function addListenerService($eventName, $callback, $priority = 0)
{
if (!is_array($callback) || 2 !== count($callback)) {
throw new \InvalidArgumentException(&#039;Expected an array(&quot;service&quot;, &quot;method&quot;) argument&#039;);
}
$this-&gt;listenerIds[$eventName][] = array($callback[0], $callback[1], $priority);
}
public function removeListener($eventName, $listener)
{
$this-&gt;lazyLoad($eventName);
if (isset($this-&gt;listeners[$eventName])) {
foreach ($this-&gt;listeners[$eventName] as $key =&gt; $l) {
foreach ($this-&gt;listenerIds[$eventName] as $i =&gt; $args) {
list($serviceId, $method, $priority) = $args;
if ($key === $serviceId.&#039;.&#039;.$method) {
if ($listener === array($l, $method)) {
unset($this-&gt;listeners[$eventName][$key]);
if (empty($this-&gt;listeners[$eventName])) {
unset($this-&gt;listeners[$eventName]);
}
unset($this-&gt;listenerIds[$eventName][$i]);
if (empty($this-&gt;listenerIds[$eventName])) {
unset($this-&gt;listenerIds[$eventName]);
}
}
}
}
}
}
parent::removeListener($eventName, $listener);
}
public function hasListeners($eventName = null)
{
if (null === $eventName) {
return (Boolean) count($this-&gt;listenerIds) || (Boolean) count($this-&gt;listeners);
}
if (isset($this-&gt;listenerIds[$eventName])) {
return true;
}
return parent::hasListeners($eventName);
}
public function getListeners($eventName = null)
{
if (null === $eventName) {
foreach (array_keys($this-&gt;listenerIds) as $serviceEventName) {
$this-&gt;lazyLoad($serviceEventName);
}
} else {
$this-&gt;lazyLoad($eventName);
}
return parent::getListeners($eventName);
}
public function addSubscriberService($serviceId, $class)
{
foreach ($class::getSubscribedEvents() as $eventName =&gt; $params) {
if (is_string($params)) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $params, 0);
} elseif (is_string($params[0])) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $params[0], isset($params[1]) ? $params[1] : 0);
} else {
foreach ($params as $listener) {
$this-&gt;listenerIds[$eventName][] = array($serviceId, $listener[0], isset($listener[1]) ? $listener[1] : 0);
}
}
}
}
public function dispatch($eventName, Event $event = null)
{
$this-&gt;lazyLoad($eventName);
return parent::dispatch($eventName, $event);
}
public function getContainer()
{
return $this-&gt;container;
}
protected function lazyLoad($eventName)
{
if (isset($this-&gt;listenerIds[$eventName])) {
foreach ($this-&gt;listenerIds[$eventName] as $args) {
list($serviceId, $method, $priority) = $args;
$listener = $this-&gt;container-&gt;get($serviceId);
$key = $serviceId.&#039;.&#039;.$method;
if (!isset($this-&gt;listeners[$eventName][$key])) {
$this-&gt;addListener($eventName, array($listener, $method), $priority);
} elseif ($listener !== $this-&gt;listeners[$eventName][$key]) {
parent::removeListener($eventName, array($this-&gt;listeners[$eventName][$key], $method));
$this-&gt;addListener($eventName, array($listener, $method), $priority);
}
$this-&gt;listeners[$eventName][$key] = $listener;
}
}
}
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class ResponseListener implements EventSubscriberInterface
{
private $charset;
public function __construct($charset)
{
$this-&gt;charset = $charset;
}
public function onKernelResponse(FilterResponseEvent $event)
{
if (!$event-&gt;isMasterRequest()) {
return;
}
$response = $event-&gt;getResponse();
if (null === $response-&gt;getCharset()) {
$response-&gt;setCharset($this-&gt;charset);
}
$response-&gt;prepare($event-&gt;getRequest());
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::RESPONSE =&gt;&#039;onKernelResponse&#039;,
);
}
}
}
namespace Symfony\Component\HttpKernel\EventListener
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\Event\FinishRequestEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Exception\MethodNotAllowedHttpException;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\RequestStack;
use Symfony\Component\Routing\Exception\MethodNotAllowedException;
use Symfony\Component\Routing\Exception\ResourceNotFoundException;
use Symfony\Component\Routing\Matcher\UrlMatcherInterface;
use Symfony\Component\Routing\Matcher\RequestMatcherInterface;
use Symfony\Component\Routing\RequestContext;
use Symfony\Component\Routing\RequestContextAwareInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\HttpFoundation\Request;
class RouterListener implements EventSubscriberInterface
{
private $matcher;
private $context;
private $logger;
private $request;
private $requestStack;
public function __construct($matcher, RequestContext $context = null, LoggerInterface $logger = null, RequestStack $requestStack = null)
{
if (!$matcher instanceof UrlMatcherInterface &amp;&amp; !$matcher instanceof RequestMatcherInterface) {
throw new \InvalidArgumentException(&#039;Matcher must either implement UrlMatcherInterface or RequestMatcherInterface.&#039;);
}
if (null === $context &amp;&amp; !$matcher instanceof RequestContextAwareInterface) {
throw new \InvalidArgumentException(&#039;You must either pass a RequestContext or the matcher must implement RequestContextAwareInterface.&#039;);
}
$this-&gt;matcher = $matcher;
$this-&gt;context = $context ?: $matcher-&gt;getContext();
$this-&gt;requestStack = $requestStack;
$this-&gt;logger = $logger;
}
public function setRequest(Request $request = null)
{
if (null !== $request &amp;&amp; $this-&gt;request !== $request) {
$this-&gt;context-&gt;fromRequest($request);
}
$this-&gt;request = $request;
}
public function onKernelFinishRequest(FinishRequestEvent $event)
{
if (null === $this-&gt;requestStack) {
return; }
$this-&gt;setRequest($this-&gt;requestStack-&gt;getParentRequest());
}
public function onKernelRequest(GetResponseEvent $event)
{
$request = $event-&gt;getRequest();
if (null !== $this-&gt;requestStack) {
$this-&gt;setRequest($request);
}
if ($request-&gt;attributes-&gt;has(&#039;_controller&#039;)) {
return;
}
try {
if ($this-&gt;matcher instanceof RequestMatcherInterface) {
$parameters = $this-&gt;matcher-&gt;matchRequest($request);
} else {
$parameters = $this-&gt;matcher-&gt;match($request-&gt;getPathInfo());
}
if (null !== $this-&gt;logger) {
$this-&gt;logger-&gt;info(sprintf(&#039;Matched route &quot;%s&quot; (parameters: %s)&#039;, $parameters[&#039;_route&#039;], $this-&gt;parametersToString($parameters)));
}
$request-&gt;attributes-&gt;add($parameters);
unset($parameters[&#039;_route&#039;]);
unset($parameters[&#039;_controller&#039;]);
$request-&gt;attributes-&gt;set(&#039;_route_params&#039;, $parameters);
} catch (ResourceNotFoundException $e) {
$message = sprintf(&#039;No route found for &quot;%s %s&quot;&#039;, $request-&gt;getMethod(), $request-&gt;getPathInfo());
if ($referer = $request-&gt;headers-&gt;get(&#039;referer&#039;)) {
$message .= sprintf(&#039; (from &quot;%s&quot;)&#039;, $referer);
}
throw new NotFoundHttpException($message, $e);
} catch (MethodNotAllowedException $e) {
$message = sprintf(&#039;No route found for &quot;%s %s&quot;: Method Not Allowed (Allow: %s)&#039;, $request-&gt;getMethod(), $request-&gt;getPathInfo(), implode(&#039;, &#039;, $e-&gt;getAllowedMethods()));
throw new MethodNotAllowedHttpException($e-&gt;getAllowedMethods(), $message, $e);
}
}
private function parametersToString(array $parameters)
{
$pieces = array();
foreach ($parameters as $key =&gt; $val) {
$pieces[] = sprintf(&#039;&quot;%s&quot;: &quot;%s&quot;&#039;, $key, (is_string($val) ? $val : json_encode($val)));
}
return implode(&#039;, &#039;, $pieces);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(array(&#039;onKernelRequest&#039;, 32)),
KernelEvents::FINISH_REQUEST =&gt; array(array(&#039;onKernelFinishRequest&#039;, 0)),
);
}
}
}
namespace Symfony\Component\HttpKernel\Controller
{
use Symfony\Component\HttpFoundation\Request;
interface ControllerResolverInterface
{
public function getController(Request $request);
public function getArguments(Request $request, $controller);
}
}
namespace Symfony\Component\HttpKernel\Controller
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpFoundation\Request;
class ControllerResolver implements ControllerResolverInterface
{
private $logger;
public function __construct(LoggerInterface $logger = null)
{
$this-&gt;logger = $logger;
}
public function getController(Request $request)
{
if (!$controller = $request-&gt;attributes-&gt;get(&#039;_controller&#039;)) {
if (null !== $this-&gt;logger) {
$this-&gt;logger-&gt;warning(&#039;Unable to look for the controller as the &quot;_controller&quot; parameter is missing&#039;);
}
return false;
}
if (is_array($controller) || (is_object($controller) &amp;&amp; method_exists($controller,&#039;__invoke&#039;))) {
return $controller;
}
if (false === strpos($controller,&#039;:&#039;)) {
if (method_exists($controller,&#039;__invoke&#039;)) {
return new $controller();
} elseif (function_exists($controller)) {
return $controller;
}
}
$callable = $this-&gt;createController($controller);
if (!is_callable($callable)) {
throw new \InvalidArgumentException(sprintf(&#039;The controller for URI &quot;%s&quot; is not callable.&#039;, $request-&gt;getPathInfo()));
}
return $callable;
}
public function getArguments(Request $request, $controller)
{
if (is_array($controller)) {
$r = new \ReflectionMethod($controller[0], $controller[1]);
} elseif (is_object($controller) &amp;&amp; !$controller instanceof \Closure) {
$r = new \ReflectionObject($controller);
$r = $r-&gt;getMethod(&#039;__invoke&#039;);
} else {
$r = new \ReflectionFunction($controller);
}
return $this-&gt;doGetArguments($request, $controller, $r-&gt;getParameters());
}
protected function doGetArguments(Request $request, $controller, array $parameters)
{
$attributes = $request-&gt;attributes-&gt;all();
$arguments = array();
foreach ($parameters as $param) {
if (array_key_exists($param-&gt;name, $attributes)) {
$arguments[] = $attributes[$param-&gt;name];
} elseif ($param-&gt;getClass() &amp;&amp; $param-&gt;getClass()-&gt;isInstance($request)) {
$arguments[] = $request;
} elseif ($param-&gt;isDefaultValueAvailable()) {
$arguments[] = $param-&gt;getDefaultValue();
} else {
if (is_array($controller)) {
$repr = sprintf(&#039;%s::%s()&#039;, get_class($controller[0]), $controller[1]);
} elseif (is_object($controller)) {
$repr = get_class($controller);
} else {
$repr = $controller;
}
throw new \RuntimeException(sprintf(&#039;Controller &quot;%s&quot; requires that you provide a value for the &quot;$%s&quot; argument (because there is no default value or because there is a non optional argument after this one).&#039;, $repr, $param-&gt;name));
}
}
return $arguments;
}
protected function createController($controller)
{
if (false === strpos($controller,&#039;::&#039;)) {
throw new \InvalidArgumentException(sprintf(&#039;Unable to find controller &quot;%s&quot;.&#039;, $controller));
}
list($class, $method) = explode(&#039;::&#039;, $controller, 2);
if (!class_exists($class)) {
throw new \InvalidArgumentException(sprintf(&#039;Class &quot;%s&quot; does not exist.&#039;, $class));
}
return array(new $class(), $method);
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\EventDispatcher\Event;
class KernelEvent extends Event
{
private $kernel;
private $request;
private $requestType;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType)
{
$this-&gt;kernel = $kernel;
$this-&gt;request = $request;
$this-&gt;requestType = $requestType;
}
public function getKernel()
{
return $this-&gt;kernel;
}
public function getRequest()
{
return $this-&gt;request;
}
public function getRequestType()
{
return $this-&gt;requestType;
}
public function isMasterRequest()
{
return HttpKernelInterface::MASTER_REQUEST === $this-&gt;requestType;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class FilterControllerEvent extends KernelEvent
{
private $controller;
public function __construct(HttpKernelInterface $kernel, $controller, Request $request, $requestType)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setController($controller);
}
public function getController()
{
return $this-&gt;controller;
}
public function setController($controller)
{
if (!is_callable($controller)) {
throw new \LogicException(sprintf(&#039;The controller must be a callable (%s given).&#039;, $this-&gt;varToString($controller)));
}
$this-&gt;controller = $controller;
}
private function varToString($var)
{
if (is_object($var)) {
return sprintf(&#039;Object(%s)&#039;, get_class($var));
}
if (is_array($var)) {
$a = array();
foreach ($var as $k =&gt; $v) {
$a[] = sprintf(&#039;%s =&gt; %s&#039;, $k, $this-&gt;varToString($v));
}
return sprintf(&quot;Array(%s)&quot;, implode(&#039;, &#039;, $a));
}
if (is_resource($var)) {
return sprintf(&#039;Resource(%s)&#039;, get_resource_type($var));
}
if (null === $var) {
return&#039;null&#039;;
}
if (false === $var) {
return&#039;false&#039;;
}
if (true === $var) {
return&#039;true&#039;;
}
return (string) $var;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpFoundation\Response;
class FilterResponseEvent extends KernelEvent
{
private $response;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, Response $response)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setResponse($response);
}
public function getResponse()
{
return $this-&gt;response;
}
public function setResponse(Response $response)
{
$this-&gt;response = $response;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpFoundation\Response;
class GetResponseEvent extends KernelEvent
{
private $response;
public function getResponse()
{
return $this-&gt;response;
}
public function setResponse(Response $response)
{
$this-&gt;response = $response;
$this-&gt;stopPropagation();
}
public function hasResponse()
{
return null !== $this-&gt;response;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class GetResponseForControllerResultEvent extends GetResponseEvent
{
private $controllerResult;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, $controllerResult)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;controllerResult = $controllerResult;
}
public function getControllerResult()
{
return $this-&gt;controllerResult;
}
public function setControllerResult($controllerResult)
{
$this-&gt;controllerResult = $controllerResult;
}
}
}
namespace Symfony\Component\HttpKernel\Event
{
use Symfony\Component\HttpKernel\HttpKernelInterface;
use Symfony\Component\HttpFoundation\Request;
class GetResponseForExceptionEvent extends GetResponseEvent
{
private $exception;
public function __construct(HttpKernelInterface $kernel, Request $request, $requestType, \Exception $e)
{
parent::__construct($kernel, $request, $requestType);
$this-&gt;setException($e);
}
public function getException()
{
return $this-&gt;exception;
}
public function setException(\Exception $exception)
{
$this-&gt;exception = $exception;
}
}
}
namespace Symfony\Component\HttpKernel
{
final class KernelEvents
{
const REQUEST =&#039;kernel.request&#039;;
const EXCEPTION =&#039;kernel.exception&#039;;
const VIEW =&#039;kernel.view&#039;;
const CONTROLLER =&#039;kernel.controller&#039;;
const RESPONSE =&#039;kernel.response&#039;;
const TERMINATE =&#039;kernel.terminate&#039;;
const FINISH_REQUEST =&#039;kernel.finish_request&#039;;
}
}
namespace Symfony\Component\HttpKernel\Config
{
use Symfony\Component\Config\FileLocator as BaseFileLocator;
use Symfony\Component\HttpKernel\KernelInterface;
class FileLocator extends BaseFileLocator
{
private $kernel;
private $path;
public function __construct(KernelInterface $kernel, $path = null, array $paths = array())
{
$this-&gt;kernel = $kernel;
if (null !== $path) {
$this-&gt;path = $path;
$paths[] = $path;
}
parent::__construct($paths);
}
public function locate($file, $currentPath = null, $first = true)
{
if (&#039;@&#039;=== $file[0]) {
return $this-&gt;kernel-&gt;locateResource($file, $this-&gt;path, $first);
}
return parent::locate($file, $currentPath, $first);
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Controller
{
use Symfony\Component\HttpKernel\KernelInterface;
class ControllerNameParser
{
protected $kernel;
public function __construct(KernelInterface $kernel)
{
$this-&gt;kernel = $kernel;
}
public function parse($controller)
{
if (3 != count($parts = explode(&#039;:&#039;, $controller))) {
throw new \InvalidArgumentException(sprintf(&#039;The &quot;%s&quot; controller is not a valid &quot;a:b:c&quot; controller string.&#039;, $controller));
}
list($bundle, $controller, $action) = $parts;
$controller = str_replace(&#039;/&#039;,&#039;\\&#039;, $controller);
$bundles = array();
foreach ($this-&gt;kernel-&gt;getBundle($bundle, false) as $b) {
$try = $b-&gt;getNamespace().&#039;\\Controller\\&#039;.$controller.&#039;Controller&#039;;
if (class_exists($try)) {
return $try.&#039;::&#039;.$action.&#039;Action&#039;;
}
$bundles[] = $b-&gt;getName();
$msg = sprintf(&#039;Unable to find controller &quot;%s:%s&quot; - class &quot;%s&quot; does not exist.&#039;, $bundle, $controller, $try);
}
if (count($bundles) &gt; 1) {
$msg = sprintf(&#039;Unable to find controller &quot;%s:%s&quot; in bundles %s.&#039;, $bundle, $controller, implode(&#039;, &#039;, $bundles));
}
throw new \InvalidArgumentException($msg);
}
public function build($controller)
{
if (0 === preg_match(&#039;#^(.*?\\\\Controller\\\\(.+)Controller)::(.+)Action$#&#039;, $controller, $match)) {
throw new \InvalidArgumentException(sprintf(&#039;The &quot;%s&quot; controller is not a valid &quot;class::method&quot; string.&#039;, $controller));
}
$className = $match[1];
$controllerName = $match[2];
$actionName = $match[3];
foreach ($this-&gt;kernel-&gt;getBundles() as $name =&gt; $bundle) {
if (0 !== strpos($className, $bundle-&gt;getNamespace())) {
continue;
}
return sprintf(&#039;%s:%s:%s&#039;, $name, $controllerName, $actionName);
}
throw new \InvalidArgumentException(sprintf(&#039;Unable to find a bundle that defines controller &quot;%s&quot;.&#039;, $controller));
}
}
}
namespace Symfony\Bundle\FrameworkBundle\Controller
{
use Psr\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Controller\ControllerResolver as BaseControllerResolver;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\ContainerAwareInterface;
class ControllerResolver extends BaseControllerResolver
{
protected $container;
protected $parser;
public function __construct(ContainerInterface $container, ControllerNameParser $parser, LoggerInterface $logger = null)
{
$this-&gt;container = $container;
$this-&gt;parser = $parser;
parent::__construct($logger);
}
protected function createController($controller)
{
if (false === strpos($controller,&#039;::&#039;)) {
$count = substr_count($controller,&#039;:&#039;);
if (2 == $count) {
$controller = $this-&gt;parser-&gt;parse($controller);
} elseif (1 == $count) {
list($service, $method) = explode(&#039;:&#039;, $controller, 2);
return array($this-&gt;container-&gt;get($service), $method);
} else {
throw new \LogicException(sprintf(&#039;Unable to parse the controller name &quot;%s&quot;.&#039;, $controller));
}
}
list($class, $method) = explode(&#039;::&#039;, $controller, 2);
if (!class_exists($class)) {
throw new \InvalidArgumentException(sprintf(&#039;Class &quot;%s&quot; does not exist.&#039;, $class));
}
$controller = new $class();
if ($controller instanceof ContainerAwareInterface) {
$controller-&gt;setContainer($this-&gt;container);
}
return array($controller, $method);
}
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpKernel\Event\GetResponseEvent;
use Symfony\Component\HttpKernel\Event\FinishRequestEvent;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class Firewall implements EventSubscriberInterface
{
private $map;
private $dispatcher;
private $exceptionListeners;
public function __construct(FirewallMapInterface $map, EventDispatcherInterface $dispatcher)
{
$this-&gt;map = $map;
$this-&gt;dispatcher = $dispatcher;
$this-&gt;exceptionListeners = new \SplObjectStorage();
}
public function onKernelRequest(GetResponseEvent $event)
{
if (!$event-&gt;isMasterRequest()) {
return;
}
list($listeners, $exception) = $this-&gt;map-&gt;getListeners($event-&gt;getRequest());
if (null !== $exception) {
$this-&gt;exceptionListeners[$event-&gt;getRequest()] = $exception;
$exception-&gt;register($this-&gt;dispatcher);
}
foreach ($listeners as $listener) {
$listener-&gt;handle($event);
if ($event-&gt;hasResponse()) {
break;
}
}
}
public function onKernelFinishRequest(FinishRequestEvent $event)
{
$request = $event-&gt;getRequest();
if (isset($this-&gt;exceptionListeners[$request])) {
$this-&gt;exceptionListeners[$request]-&gt;unregister($this-&gt;dispatcher);
unset($this-&gt;exceptionListeners[$request]);
}
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::REQUEST =&gt; array(&#039;onKernelRequest&#039;, 8),
KernelEvents::FINISH_REQUEST =&gt;&#039;onKernelFinishRequest&#039;,
);
}
}
}
namespace Symfony\Component\Security\Core
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface SecurityContextInterface
{
const ACCESS_DENIED_ERROR =&#039;_security.403_error&#039;;
const AUTHENTICATION_ERROR =&#039;_security.last_error&#039;;
const LAST_USERNAME =&#039;_security.last_username&#039;;
public function getToken();
public function setToken(TokenInterface $token = null);
public function isGranted($attributes, $object = null);
}
}
namespace Symfony\Component\Security\Core
{
use Symfony\Component\Security\Core\Exception\AuthenticationCredentialsNotFoundException;
use Symfony\Component\Security\Core\Authorization\AccessDecisionManagerInterface;
use Symfony\Component\Security\Core\Authentication\AuthenticationManagerInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class SecurityContext implements SecurityContextInterface
{
private $token;
private $accessDecisionManager;
private $authenticationManager;
private $alwaysAuthenticate;
public function __construct(AuthenticationManagerInterface $authenticationManager, AccessDecisionManagerInterface $accessDecisionManager, $alwaysAuthenticate = false)
{
$this-&gt;authenticationManager = $authenticationManager;
$this-&gt;accessDecisionManager = $accessDecisionManager;
$this-&gt;alwaysAuthenticate = $alwaysAuthenticate;
}
final public function isGranted($attributes, $object = null)
{
if (null === $this-&gt;token) {
throw new AuthenticationCredentialsNotFoundException(&#039;The security context contains no authentication token. One possible reason may be that there is no firewall configured for this URL.&#039;);
}
if ($this-&gt;alwaysAuthenticate || !$this-&gt;token-&gt;isAuthenticated()) {
$this-&gt;token = $this-&gt;authenticationManager-&gt;authenticate($this-&gt;token);
}
if (!is_array($attributes)) {
$attributes = array($attributes);
}
return $this-&gt;accessDecisionManager-&gt;decide($this-&gt;token, $attributes, $object);
}
public function getToken()
{
return $this-&gt;token;
}
public function setToken(TokenInterface $token = null)
{
$this-&gt;token = $token;
}
}
}
namespace Symfony\Component\Security\Core\User
{
use Symfony\Component\Security\Core\Exception\UsernameNotFoundException;
use Symfony\Component\Security\Core\Exception\UnsupportedUserException;
interface UserProviderInterface
{
public function loadUserByUsername($username);
public function refreshUser(UserInterface $user);
public function supportsClass($class);
}
}
namespace Symfony\Component\Security\Core\Authentication
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
interface AuthenticationManagerInterface
{
public function authenticate(TokenInterface $token);
}
}
namespace Symfony\Component\Security\Core\Authentication
{
use Symfony\Component\Security\Core\Event\AuthenticationFailureEvent;
use Symfony\Component\Security\Core\Event\AuthenticationEvent;
use Symfony\Component\Security\Core\AuthenticationEvents;
use Symfony\Component\EventDispatcher\EventDispatcherInterface;
use Symfony\Component\Security\Core\Exception\AccountStatusException;
use Symfony\Component\Security\Core\Exception\AuthenticationException;
use Symfony\Component\Security\Core\Exception\ProviderNotFoundException;
use Symfony\Component\Security\Core\Authentication\Provider\AuthenticationProviderInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class AuthenticationProviderManager implements AuthenticationManagerInterface
{
private $providers;
private $eraseCredentials;
private $eventDispatcher;
public function __construct(array $providers, $eraseCredentials = true)
{
if (!$providers) {
throw new \InvalidArgumentException(&#039;You must at least add one authentication provider.&#039;);
}
$this-&gt;providers = $providers;
$this-&gt;eraseCredentials = (Boolean) $eraseCredentials;
}
public function setEventDispatcher(EventDispatcherInterface $dispatcher)
{
$this-&gt;eventDispatcher = $dispatcher;
}
public function authenticate(TokenInterface $token)
{
$lastException = null;
$result = null;
foreach ($this-&gt;providers as $provider) {
if (!$provider-&gt;supports($token)) {
continue;
}
try {
$result = $provider-&gt;authenticate($token);
if (null !== $result) {
break;
}
} catch (AccountStatusException $e) {
$e-&gt;setToken($token);
throw $e;
} catch (AuthenticationException $e) {
$lastException = $e;
}
}
if (null !== $result) {
if (true === $this-&gt;eraseCredentials) {
$result-&gt;eraseCredentials();
}
if (null !== $this-&gt;eventDispatcher) {
$this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_SUCCESS, new AuthenticationEvent($result));
}
return $result;
}
if (null === $lastException) {
$lastException = new ProviderNotFoundException(sprintf(&#039;No Authentication Provider found for token of class &quot;%s&quot;.&#039;, get_class($token)));
}
if (null !== $this-&gt;eventDispatcher) {
$this-&gt;eventDispatcher-&gt;dispatch(AuthenticationEvents::AUTHENTICATION_FAILURE, new AuthenticationFailureEvent($token, $lastException));
}
$lastException-&gt;setToken($token);
throw $lastException;
}
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface AccessDecisionManagerInterface
{
public function decide(TokenInterface $token, array $attributes, $object = null);
public function supportsAttribute($attribute);
public function supportsClass($class);
}
}
namespace Symfony\Component\Security\Core\Authorization
{
use Symfony\Component\Security\Core\Authorization\Voter\VoterInterface;
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
class AccessDecisionManager implements AccessDecisionManagerInterface
{
private $voters;
private $strategy;
private $allowIfAllAbstainDecisions;
private $allowIfEqualGrantedDeniedDecisions;
public function __construct(array $voters, $strategy =&#039;affirmative&#039;, $allowIfAllAbstainDecisions = false, $allowIfEqualGrantedDeniedDecisions = true)
{
if (!$voters) {
throw new \InvalidArgumentException(&#039;You must at least add one voter.&#039;);
}
$strategyMethod =&#039;decide&#039;.ucfirst($strategy);
if (!is_callable(array($this, $strategyMethod))) {
throw new \InvalidArgumentException(sprintf(&#039;The strategy &quot;%s&quot; is not supported.&#039;, $strategy));
}
$this-&gt;voters = $voters;
$this-&gt;strategy = $strategyMethod;
$this-&gt;allowIfAllAbstainDecisions = (Boolean) $allowIfAllAbstainDecisions;
$this-&gt;allowIfEqualGrantedDeniedDecisions = (Boolean) $allowIfEqualGrantedDeniedDecisions;
}
public function decide(TokenInterface $token, array $attributes, $object = null)
{
return $this-&gt;{$this-&gt;strategy}($token, $attributes, $object);
}
public function supportsAttribute($attribute)
{
foreach ($this-&gt;voters as $voter) {
if ($voter-&gt;supportsAttribute($attribute)) {
return true;
}
}
return false;
}
public function supportsClass($class)
{
foreach ($this-&gt;voters as $voter) {
if ($voter-&gt;supportsClass($class)) {
return true;
}
}
return false;
}
private function decideAffirmative(TokenInterface $token, array $attributes, $object = null)
{
$deny = 0;
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, $attributes);
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
return true;
case VoterInterface::ACCESS_DENIED:
++$deny;
break;
default:
break;
}
}
if ($deny &gt; 0) {
return false;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
private function decideConsensus(TokenInterface $token, array $attributes, $object = null)
{
$grant = 0;
$deny = 0;
$abstain = 0;
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, $attributes);
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
++$grant;
break;
case VoterInterface::ACCESS_DENIED:
++$deny;
break;
default:
++$abstain;
break;
}
}
if ($grant &gt; $deny) {
return true;
}
if ($deny &gt; $grant) {
return false;
}
if ($grant == $deny &amp;&amp; $grant != 0) {
return $this-&gt;allowIfEqualGrantedDeniedDecisions;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
private function decideUnanimous(TokenInterface $token, array $attributes, $object = null)
{
$grant = 0;
foreach ($attributes as $attribute) {
foreach ($this-&gt;voters as $voter) {
$result = $voter-&gt;vote($token, $object, array($attribute));
switch ($result) {
case VoterInterface::ACCESS_GRANTED:
++$grant;
break;
case VoterInterface::ACCESS_DENIED:
return false;
default:
break;
}
}
}
if ($grant &gt; 0) {
return true;
}
return $this-&gt;allowIfAllAbstainDecisions;
}
}
}
namespace Symfony\Component\Security\Core\Authorization\Voter
{
use Symfony\Component\Security\Core\Authentication\Token\TokenInterface;
interface VoterInterface
{
const ACCESS_GRANTED = 1;
const ACCESS_ABSTAIN = 0;
const ACCESS_DENIED = -1;
public function supportsAttribute($attribute);
public function supportsClass($class);
public function vote(TokenInterface $token, $object, array $attributes);
}
}
namespace Symfony\Component\Security\Http
{
use Symfony\Component\HttpFoundation\Request;
interface FirewallMapInterface
{
public function getListeners(Request $request);
}
}
namespace Symfony\Bundle\SecurityBundle\Security
{
use Symfony\Component\Security\Http\FirewallMapInterface;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\DependencyInjection\ContainerInterface;
class FirewallMap implements FirewallMapInterface
{
protected $container;
protected $map;
public function __construct(ContainerInterface $container, array $map)
{
$this-&gt;container = $container;
$this-&gt;map = $map;
}
public function getListeners(Request $request)
{
foreach ($this-&gt;map as $contextId =&gt; $requestMatcher) {
if (null === $requestMatcher || $requestMatcher-&gt;matches($request)) {
return $this-&gt;container-&gt;get($contextId)-&gt;getContext();
}
}
return array(array(), null);
}
}
}
namespace Symfony\Bundle\SecurityBundle\Security
{
use Symfony\Component\Security\Http\Firewall\ExceptionListener;
class FirewallContext
{
private $listeners;
private $exceptionListener;
public function __construct(array $listeners, ExceptionListener $exceptionListener = null)
{
$this-&gt;listeners = $listeners;
$this-&gt;exceptionListener = $exceptionListener;
}
public function getContext()
{
return array($this-&gt;listeners, $this-&gt;exceptionListener);
}
}
}
namespace Symfony\Component\HttpFoundation
{
interface RequestMatcherInterface
{
public function matches(Request $request);
}
}
namespace Symfony\Component\HttpFoundation
{
class RequestMatcher implements RequestMatcherInterface
{
private $path;
private $host;
private $methods = array();
private $ips = array();
private $attributes = array();
public function __construct($path = null, $host = null, $methods = null, $ips = null, array $attributes = array())
{
$this-&gt;matchPath($path);
$this-&gt;matchHost($host);
$this-&gt;matchMethod($methods);
$this-&gt;matchIps($ips);
foreach ($attributes as $k =&gt; $v) {
$this-&gt;matchAttribute($k, $v);
}
}
public function matchHost($regexp)
{
$this-&gt;host = $regexp;
}
public function matchPath($regexp)
{
$this-&gt;path = $regexp;
}
public function matchIp($ip)
{
$this-&gt;matchIps($ip);
}
public function matchIps($ips)
{
$this-&gt;ips = (array) $ips;
}
public function matchMethod($method)
{
$this-&gt;methods = array_map(&#039;strtoupper&#039;, (array) $method);
}
public function matchAttribute($key, $regexp)
{
$this-&gt;attributes[$key] = $regexp;
}
public function matches(Request $request)
{
if ($this-&gt;methods &amp;&amp; !in_array($request-&gt;getMethod(), $this-&gt;methods)) {
return false;
}
foreach ($this-&gt;attributes as $key =&gt; $pattern) {
if (!preg_match(&#039;{&#039;.$pattern.&#039;}&#039;, $request-&gt;attributes-&gt;get($key))) {
return false;
}
}
if (null !== $this-&gt;path &amp;&amp; !preg_match(&#039;{&#039;.$this-&gt;path.&#039;}&#039;, rawurldecode($request-&gt;getPathInfo()))) {
return false;
}
if (null !== $this-&gt;host &amp;&amp; !preg_match(&#039;{&#039;.$this-&gt;host.&#039;}i&#039;, $request-&gt;getHost())) {
return false;
}
if (IpUtils::checkIp($request-&gt;getClientIp(), $this-&gt;ips)) {
return true;
}
return count($this-&gt;ips) === 0;
}
}
}
namespace
{
class Twig_Environment
{
const VERSION =&#039;1.15.1&#039;;
protected $charset;
protected $loader;
protected $debug;
protected $autoReload;
protected $cache;
protected $lexer;
protected $parser;
protected $compiler;
protected $baseTemplateClass;
protected $extensions;
protected $parsers;
protected $visitors;
protected $filters;
protected $tests;
protected $functions;
protected $globals;
protected $runtimeInitialized;
protected $extensionInitialized;
protected $loadedTemplates;
protected $strictVariables;
protected $unaryOperators;
protected $binaryOperators;
protected $templateClassPrefix =&#039;__TwigTemplate_&#039;;
protected $functionCallbacks;
protected $filterCallbacks;
protected $staging;
public function __construct(Twig_LoaderInterface $loader = null, $options = array())
{
if (null !== $loader) {
$this-&gt;setLoader($loader);
}
$options = array_merge(array(&#039;debug&#039;=&gt; false,&#039;charset&#039;=&gt;&#039;UTF-8&#039;,&#039;base_template_class&#039;=&gt;&#039;Twig_Template&#039;,&#039;strict_variables&#039;=&gt; false,&#039;autoescape&#039;=&gt;&#039;html&#039;,&#039;cache&#039;=&gt; false,&#039;auto_reload&#039;=&gt; null,&#039;optimizations&#039;=&gt; -1,
), $options);
$this-&gt;debug = (bool) $options[&#039;debug&#039;];
$this-&gt;charset = strtoupper($options[&#039;charset&#039;]);
$this-&gt;baseTemplateClass = $options[&#039;base_template_class&#039;];
$this-&gt;autoReload = null === $options[&#039;auto_reload&#039;] ? $this-&gt;debug : (bool) $options[&#039;auto_reload&#039;];
$this-&gt;strictVariables = (bool) $options[&#039;strict_variables&#039;];
$this-&gt;runtimeInitialized = false;
$this-&gt;setCache($options[&#039;cache&#039;]);
$this-&gt;functionCallbacks = array();
$this-&gt;filterCallbacks = array();
$this-&gt;addExtension(new Twig_Extension_Core());
$this-&gt;addExtension(new Twig_Extension_Escaper($options[&#039;autoescape&#039;]));
$this-&gt;addExtension(new Twig_Extension_Optimizer($options[&#039;optimizations&#039;]));
$this-&gt;extensionInitialized = false;
$this-&gt;staging = new Twig_Extension_Staging();
}
public function getBaseTemplateClass()
{
return $this-&gt;baseTemplateClass;
}
public function setBaseTemplateClass($class)
{
$this-&gt;baseTemplateClass = $class;
}
public function enableDebug()
{
$this-&gt;debug = true;
}
public function disableDebug()
{
$this-&gt;debug = false;
}
public function isDebug()
{
return $this-&gt;debug;
}
public function enableAutoReload()
{
$this-&gt;autoReload = true;
}
public function disableAutoReload()
{
$this-&gt;autoReload = false;
}
public function isAutoReload()
{
return $this-&gt;autoReload;
}
public function enableStrictVariables()
{
$this-&gt;strictVariables = true;
}
public function disableStrictVariables()
{
$this-&gt;strictVariables = false;
}
public function isStrictVariables()
{
return $this-&gt;strictVariables;
}
public function getCache()
{
return $this-&gt;cache;
}
public function setCache($cache)
{
$this-&gt;cache = $cache ? $cache : false;
}
public function getCacheFilename($name)
{
if (false === $this-&gt;cache) {
return false;
}
$class = substr($this-&gt;getTemplateClass($name), strlen($this-&gt;templateClassPrefix));
return $this-&gt;getCache().&#039;/&#039;.substr($class, 0, 2).&#039;/&#039;.substr($class, 2, 2).&#039;/&#039;.substr($class, 4).&#039;.php&#039;;
}
public function getTemplateClass($name, $index = null)
{
return $this-&gt;templateClassPrefix.hash(&#039;sha256&#039;, $this-&gt;getLoader()-&gt;getCacheKey($name)).(null === $index ?&#039;&#039;:&#039;_&#039;.$index);
}
public function getTemplateClassPrefix()
{
return $this-&gt;templateClassPrefix;
}
public function render($name, array $context = array())
{
return $this-&gt;loadTemplate($name)-&gt;render($context);
}
public function display($name, array $context = array())
{
$this-&gt;loadTemplate($name)-&gt;display($context);
}
public function loadTemplate($name, $index = null)
{
$cls = $this-&gt;getTemplateClass($name, $index);
if (isset($this-&gt;loadedTemplates[$cls])) {
return $this-&gt;loadedTemplates[$cls];
}
if (!class_exists($cls, false)) {
if (false === $cache = $this-&gt;getCacheFilename($name)) {
eval(&#039;?&gt;&#039;.$this-&gt;compileSource($this-&gt;getLoader()-&gt;getSource($name), $name));
} else {
if (!is_file($cache) || ($this-&gt;isAutoReload() &amp;&amp; !$this-&gt;isTemplateFresh($name, filemtime($cache)))) {
$this-&gt;writeCacheFile($cache, $this-&gt;compileSource($this-&gt;getLoader()-&gt;getSource($name), $name));
}
require_once $cache;
}
}
if (!$this-&gt;runtimeInitialized) {
$this-&gt;initRuntime();
}
return $this-&gt;loadedTemplates[$cls] = new $cls($this);
}
public function isTemplateFresh($name, $time)
{
foreach ($this-&gt;extensions as $extension) {
$r = new ReflectionObject($extension);
if (filemtime($r-&gt;getFileName()) &gt; $time) {
return false;
}
}
return $this-&gt;getLoader()-&gt;isFresh($name, $time);
}
public function resolveTemplate($names)
{
if (!is_array($names)) {
$names = array($names);
}
foreach ($names as $name) {
if ($name instanceof Twig_Template) {
return $name;
}
try {
return $this-&gt;loadTemplate($name);
} catch (Twig_Error_Loader $e) {
}
}
if (1 === count($names)) {
throw $e;
}
throw new Twig_Error_Loader(sprintf(&#039;Unable to find one of the following templates: &quot;%s&quot;.&#039;, implode(&#039;&quot;, &quot;&#039;, $names)));
}
public function clearTemplateCache()
{
$this-&gt;loadedTemplates = array();
}
public function clearCacheFiles()
{
if (false === $this-&gt;cache) {
return;
}
foreach (new RecursiveIteratorIterator(new RecursiveDirectoryIterator($this-&gt;cache), RecursiveIteratorIterator::LEAVES_ONLY) as $file) {
if ($file-&gt;isFile()) {
@unlink($file-&gt;getPathname());
}
}
}
public function getLexer()
{
if (null === $this-&gt;lexer) {
$this-&gt;lexer = new Twig_Lexer($this);
}
return $this-&gt;lexer;
}
public function setLexer(Twig_LexerInterface $lexer)
{
$this-&gt;lexer = $lexer;
}
public function tokenize($source, $name = null)
{
return $this-&gt;getLexer()-&gt;tokenize($source, $name);
}
public function getParser()
{
if (null === $this-&gt;parser) {
$this-&gt;parser = new Twig_Parser($this);
}
return $this-&gt;parser;
}
public function setParser(Twig_ParserInterface $parser)
{
$this-&gt;parser = $parser;
}
public function parse(Twig_TokenStream $stream)
{
return $this-&gt;getParser()-&gt;parse($stream);
}
public function getCompiler()
{
if (null === $this-&gt;compiler) {
$this-&gt;compiler = new Twig_Compiler($this);
}
return $this-&gt;compiler;
}
public function setCompiler(Twig_CompilerInterface $compiler)
{
$this-&gt;compiler = $compiler;
}
public function compile(Twig_NodeInterface $node)
{
return $this-&gt;getCompiler()-&gt;compile($node)-&gt;getSource();
}
public function compileSource($source, $name = null)
{
try {
return $this-&gt;compile($this-&gt;parse($this-&gt;tokenize($source, $name)));
} catch (Twig_Error $e) {
$e-&gt;setTemplateFile($name);
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Syntax(sprintf(&#039;An exception has been thrown during the compilation of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $name, $e);
}
}
public function setLoader(Twig_LoaderInterface $loader)
{
$this-&gt;loader = $loader;
}
public function getLoader()
{
if (null === $this-&gt;loader) {
throw new LogicException(&#039;You must set a loader first.&#039;);
}
return $this-&gt;loader;
}
public function setCharset($charset)
{
$this-&gt;charset = strtoupper($charset);
}
public function getCharset()
{
return $this-&gt;charset;
}
public function initRuntime()
{
$this-&gt;runtimeInitialized = true;
foreach ($this-&gt;getExtensions() as $extension) {
$extension-&gt;initRuntime($this);
}
}
public function hasExtension($name)
{
return isset($this-&gt;extensions[$name]);
}
public function getExtension($name)
{
if (!isset($this-&gt;extensions[$name])) {
throw new Twig_Error_Runtime(sprintf(&#039;The &quot;%s&quot; extension is not enabled.&#039;, $name));
}
return $this-&gt;extensions[$name];
}
public function addExtension(Twig_ExtensionInterface $extension)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to register extension &quot;%s&quot; as extensions have already been initialized.&#039;, $extension-&gt;getName()));
}
$this-&gt;extensions[$extension-&gt;getName()] = $extension;
}
public function removeExtension($name)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to remove extension &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
unset($this-&gt;extensions[$name]);
}
public function setExtensions(array $extensions)
{
foreach ($extensions as $extension) {
$this-&gt;addExtension($extension);
}
}
public function getExtensions()
{
return $this-&gt;extensions;
}
public function addTokenParser(Twig_TokenParserInterface $parser)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(&#039;Unable to add a token parser as extensions have already been initialized.&#039;);
}
$this-&gt;staging-&gt;addTokenParser($parser);
}
public function getTokenParsers()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;parsers;
}
public function getTags()
{
$tags = array();
foreach ($this-&gt;getTokenParsers()-&gt;getParsers() as $parser) {
if ($parser instanceof Twig_TokenParserInterface) {
$tags[$parser-&gt;getTag()] = $parser;
}
}
return $tags;
}
public function addNodeVisitor(Twig_NodeVisitorInterface $visitor)
{
if ($this-&gt;extensionInitialized) {
throw new LogicException(&#039;Unable to add a node visitor as extensions have already been initialized.&#039;);
}
$this-&gt;staging-&gt;addNodeVisitor($visitor);
}
public function getNodeVisitors()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;visitors;
}
public function addFilter($name, $filter = null)
{
if (!$name instanceof Twig_SimpleFilter &amp;&amp; !($filter instanceof Twig_SimpleFilter || $filter instanceof Twig_FilterInterface)) {
throw new LogicException(&#039;A filter must be an instance of Twig_FilterInterface or Twig_SimpleFilter&#039;);
}
if ($name instanceof Twig_SimpleFilter) {
$filter = $name;
$name = $filter-&gt;getName();
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add filter &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addFilter($name, $filter);
}
public function getFilter($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;filters[$name])) {
return $this-&gt;filters[$name];
}
foreach ($this-&gt;filters as $pattern =&gt; $filter) {
$pattern = str_replace(&#039;\\*&#039;,&#039;(.*?)&#039;, preg_quote($pattern,&#039;#&#039;), $count);
if ($count) {
if (preg_match(&#039;#^&#039;.$pattern.&#039;$#&#039;, $name, $matches)) {
array_shift($matches);
$filter-&gt;setArguments($matches);
return $filter;
}
}
}
foreach ($this-&gt;filterCallbacks as $callback) {
if (false !== $filter = call_user_func($callback, $name)) {
return $filter;
}
}
return false;
}
public function registerUndefinedFilterCallback($callable)
{
$this-&gt;filterCallbacks[] = $callable;
}
public function getFilters()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;filters;
}
public function addTest($name, $test = null)
{
if (!$name instanceof Twig_SimpleTest &amp;&amp; !($test instanceof Twig_SimpleTest || $test instanceof Twig_TestInterface)) {
throw new LogicException(&#039;A test must be an instance of Twig_TestInterface or Twig_SimpleTest&#039;);
}
if ($name instanceof Twig_SimpleTest) {
$test = $name;
$name = $test-&gt;getName();
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add test &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addTest($name, $test);
}
public function getTests()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;tests;
}
public function getTest($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;tests[$name])) {
return $this-&gt;tests[$name];
}
return false;
}
public function addFunction($name, $function = null)
{
if (!$name instanceof Twig_SimpleFunction &amp;&amp; !($function instanceof Twig_SimpleFunction || $function instanceof Twig_FunctionInterface)) {
throw new LogicException(&#039;A function must be an instance of Twig_FunctionInterface or Twig_SimpleFunction&#039;);
}
if ($name instanceof Twig_SimpleFunction) {
$function = $name;
$name = $function-&gt;getName();
}
if ($this-&gt;extensionInitialized) {
throw new LogicException(sprintf(&#039;Unable to add function &quot;%s&quot; as extensions have already been initialized.&#039;, $name));
}
$this-&gt;staging-&gt;addFunction($name, $function);
}
public function getFunction($name)
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
if (isset($this-&gt;functions[$name])) {
return $this-&gt;functions[$name];
}
foreach ($this-&gt;functions as $pattern =&gt; $function) {
$pattern = str_replace(&#039;\\*&#039;,&#039;(.*?)&#039;, preg_quote($pattern,&#039;#&#039;), $count);
if ($count) {
if (preg_match(&#039;#^&#039;.$pattern.&#039;$#&#039;, $name, $matches)) {
array_shift($matches);
$function-&gt;setArguments($matches);
return $function;
}
}
}
foreach ($this-&gt;functionCallbacks as $callback) {
if (false !== $function = call_user_func($callback, $name)) {
return $function;
}
}
return false;
}
public function registerUndefinedFunctionCallback($callable)
{
$this-&gt;functionCallbacks[] = $callable;
}
public function getFunctions()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;functions;
}
public function addGlobal($name, $value)
{
if ($this-&gt;extensionInitialized || $this-&gt;runtimeInitialized) {
if (null === $this-&gt;globals) {
$this-&gt;globals = $this-&gt;initGlobals();
}
}
if ($this-&gt;extensionInitialized || $this-&gt;runtimeInitialized) {
$this-&gt;globals[$name] = $value;
} else {
$this-&gt;staging-&gt;addGlobal($name, $value);
}
}
public function getGlobals()
{
if (!$this-&gt;runtimeInitialized &amp;&amp; !$this-&gt;extensionInitialized) {
return $this-&gt;initGlobals();
}
if (null === $this-&gt;globals) {
$this-&gt;globals = $this-&gt;initGlobals();
}
return $this-&gt;globals;
}
public function mergeGlobals(array $context)
{
foreach ($this-&gt;getGlobals() as $key =&gt; $value) {
if (!array_key_exists($key, $context)) {
$context[$key] = $value;
}
}
return $context;
}
public function getUnaryOperators()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;unaryOperators;
}
public function getBinaryOperators()
{
if (!$this-&gt;extensionInitialized) {
$this-&gt;initExtensions();
}
return $this-&gt;binaryOperators;
}
public function computeAlternatives($name, $items)
{
$alternatives = array();
foreach ($items as $item) {
$lev = levenshtein($name, $item);
if ($lev &lt;= strlen($name) / 3 || false !== strpos($item, $name)) {
$alternatives[$item] = $lev;
}
}
asort($alternatives);
return array_keys($alternatives);
}
protected function initGlobals()
{
$globals = array();
foreach ($this-&gt;extensions as $extension) {
$extGlob = $extension-&gt;getGlobals();
if (!is_array($extGlob)) {
throw new UnexpectedValueException(sprintf(&#039;&quot;%s::getGlobals()&quot; must return an array of globals.&#039;, get_class($extension)));
}
$globals[] = $extGlob;
}
$globals[] = $this-&gt;staging-&gt;getGlobals();
return call_user_func_array(&#039;array_merge&#039;, $globals);
}
protected function initExtensions()
{
if ($this-&gt;extensionInitialized) {
return;
}
$this-&gt;extensionInitialized = true;
$this-&gt;parsers = new Twig_TokenParserBroker();
$this-&gt;filters = array();
$this-&gt;functions = array();
$this-&gt;tests = array();
$this-&gt;visitors = array();
$this-&gt;unaryOperators = array();
$this-&gt;binaryOperators = array();
foreach ($this-&gt;extensions as $extension) {
$this-&gt;initExtension($extension);
}
$this-&gt;initExtension($this-&gt;staging);
}
protected function initExtension(Twig_ExtensionInterface $extension)
{
foreach ($extension-&gt;getFilters() as $name =&gt; $filter) {
if ($name instanceof Twig_SimpleFilter) {
$filter = $name;
$name = $filter-&gt;getName();
} elseif ($filter instanceof Twig_SimpleFilter) {
$name = $filter-&gt;getName();
}
$this-&gt;filters[$name] = $filter;
}
foreach ($extension-&gt;getFunctions() as $name =&gt; $function) {
if ($name instanceof Twig_SimpleFunction) {
$function = $name;
$name = $function-&gt;getName();
} elseif ($function instanceof Twig_SimpleFunction) {
$name = $function-&gt;getName();
}
$this-&gt;functions[$name] = $function;
}
foreach ($extension-&gt;getTests() as $name =&gt; $test) {
if ($name instanceof Twig_SimpleTest) {
$test = $name;
$name = $test-&gt;getName();
} elseif ($test instanceof Twig_SimpleTest) {
$name = $test-&gt;getName();
}
$this-&gt;tests[$name] = $test;
}
foreach ($extension-&gt;getTokenParsers() as $parser) {
if ($parser instanceof Twig_TokenParserInterface) {
$this-&gt;parsers-&gt;addTokenParser($parser);
} elseif ($parser instanceof Twig_TokenParserBrokerInterface) {
$this-&gt;parsers-&gt;addTokenParserBroker($parser);
} else {
throw new LogicException(&#039;getTokenParsers() must return an array of Twig_TokenParserInterface or Twig_TokenParserBrokerInterface instances&#039;);
}
}
foreach ($extension-&gt;getNodeVisitors() as $visitor) {
$this-&gt;visitors[] = $visitor;
}
if ($operators = $extension-&gt;getOperators()) {
if (2 !== count($operators)) {
throw new InvalidArgumentException(sprintf(&#039;&quot;%s::getOperators()&quot; does not return a valid operators array.&#039;, get_class($extension)));
}
$this-&gt;unaryOperators = array_merge($this-&gt;unaryOperators, $operators[0]);
$this-&gt;binaryOperators = array_merge($this-&gt;binaryOperators, $operators[1]);
}
}
protected function writeCacheFile($file, $content)
{
$dir = dirname($file);
if (!is_dir($dir)) {
if (false === @mkdir($dir, 0777, true) &amp;&amp; !is_dir($dir)) {
throw new RuntimeException(sprintf(&quot;Unable to create the cache directory (%s).&quot;, $dir));
}
} elseif (!is_writable($dir)) {
throw new RuntimeException(sprintf(&quot;Unable to write in the cache directory (%s).&quot;, $dir));
}
$tmpFile = tempnam($dir, basename($file));
if (false !== @file_put_contents($tmpFile, $content)) {
if (@rename($tmpFile, $file) || (@copy($tmpFile, $file) &amp;&amp; unlink($tmpFile))) {
@chmod($file, 0666 &amp; ~umask());
return;
}
}
throw new RuntimeException(sprintf(&#039;Failed to write cache file &quot;%s&quot;.&#039;, $file));
}
}
}
namespace
{
interface Twig_ExtensionInterface
{
public function initRuntime(Twig_Environment $environment);
public function getTokenParsers();
public function getNodeVisitors();
public function getFilters();
public function getTests();
public function getFunctions();
public function getOperators();
public function getGlobals();
public function getName();
}
}
namespace
{
abstract class Twig_Extension implements Twig_ExtensionInterface
{
public function initRuntime(Twig_Environment $environment)
{
}
public function getTokenParsers()
{
return array();
}
public function getNodeVisitors()
{
return array();
}
public function getFilters()
{
return array();
}
public function getTests()
{
return array();
}
public function getFunctions()
{
return array();
}
public function getOperators()
{
return array();
}
public function getGlobals()
{
return array();
}
}
}
namespace
{
if (!defined(&#039;ENT_SUBSTITUTE&#039;)) {
define(&#039;ENT_SUBSTITUTE&#039;, 0);
}
class Twig_Extension_Core extends Twig_Extension
{
protected $dateFormats = array(&#039;F j, Y H:i&#039;,&#039;%d days&#039;);
protected $numberFormat = array(0,&#039;.&#039;,&#039;,&#039;);
protected $timezone = null;
protected $escapers = array();
public function setEscaper($strategy, $callable)
{
$this-&gt;escapers[$strategy] = $callable;
}
public function getEscapers()
{
return $this-&gt;escapers;
}
public function setDateFormat($format = null, $dateIntervalFormat = null)
{
if (null !== $format) {
$this-&gt;dateFormats[0] = $format;
}
if (null !== $dateIntervalFormat) {
$this-&gt;dateFormats[1] = $dateIntervalFormat;
}
}
public function getDateFormat()
{
return $this-&gt;dateFormats;
}
public function setTimezone($timezone)
{
$this-&gt;timezone = $timezone instanceof DateTimeZone ? $timezone : new DateTimeZone($timezone);
}
public function getTimezone()
{
if (null === $this-&gt;timezone) {
$this-&gt;timezone = new DateTimeZone(date_default_timezone_get());
}
return $this-&gt;timezone;
}
public function setNumberFormat($decimal, $decimalPoint, $thousandSep)
{
$this-&gt;numberFormat = array($decimal, $decimalPoint, $thousandSep);
}
public function getNumberFormat()
{
return $this-&gt;numberFormat;
}
public function getTokenParsers()
{
return array(
new Twig_TokenParser_For(),
new Twig_TokenParser_If(),
new Twig_TokenParser_Extends(),
new Twig_TokenParser_Include(),
new Twig_TokenParser_Block(),
new Twig_TokenParser_Use(),
new Twig_TokenParser_Filter(),
new Twig_TokenParser_Macro(),
new Twig_TokenParser_Import(),
new Twig_TokenParser_From(),
new Twig_TokenParser_Set(),
new Twig_TokenParser_Spaceless(),
new Twig_TokenParser_Flush(),
new Twig_TokenParser_Do(),
new Twig_TokenParser_Embed(),
);
}
public function getFilters()
{
$filters = array(
new Twig_SimpleFilter(&#039;date&#039;,&#039;twig_date_format_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;date_modify&#039;,&#039;twig_date_modify_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;format&#039;,&#039;sprintf&#039;),
new Twig_SimpleFilter(&#039;replace&#039;,&#039;strtr&#039;),
new Twig_SimpleFilter(&#039;number_format&#039;,&#039;twig_number_format_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;abs&#039;,&#039;abs&#039;),
new Twig_SimpleFilter(&#039;round&#039;,&#039;twig_round&#039;),
new Twig_SimpleFilter(&#039;url_encode&#039;,&#039;twig_urlencode_filter&#039;),
new Twig_SimpleFilter(&#039;json_encode&#039;,&#039;twig_jsonencode_filter&#039;),
new Twig_SimpleFilter(&#039;convert_encoding&#039;,&#039;twig_convert_encoding&#039;),
new Twig_SimpleFilter(&#039;title&#039;,&#039;twig_title_string_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;capitalize&#039;,&#039;twig_capitalize_string_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;upper&#039;,&#039;strtoupper&#039;),
new Twig_SimpleFilter(&#039;lower&#039;,&#039;strtolower&#039;),
new Twig_SimpleFilter(&#039;striptags&#039;,&#039;strip_tags&#039;),
new Twig_SimpleFilter(&#039;trim&#039;,&#039;trim&#039;),
new Twig_SimpleFilter(&#039;nl2br&#039;,&#039;nl2br&#039;, array(&#039;pre_escape&#039;=&gt;&#039;html&#039;,&#039;is_safe&#039;=&gt; array(&#039;html&#039;))),
new Twig_SimpleFilter(&#039;join&#039;,&#039;twig_join_filter&#039;),
new Twig_SimpleFilter(&#039;split&#039;,&#039;twig_split_filter&#039;),
new Twig_SimpleFilter(&#039;sort&#039;,&#039;twig_sort_filter&#039;),
new Twig_SimpleFilter(&#039;merge&#039;,&#039;twig_array_merge&#039;),
new Twig_SimpleFilter(&#039;batch&#039;,&#039;twig_array_batch&#039;),
new Twig_SimpleFilter(&#039;reverse&#039;,&#039;twig_reverse_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;length&#039;,&#039;twig_length_filter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;slice&#039;,&#039;twig_slice&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;first&#039;,&#039;twig_first&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;last&#039;,&#039;twig_last&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFilter(&#039;default&#039;,&#039;_twig_default_filter&#039;, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Filter_Default&#039;)),
new Twig_SimpleFilter(&#039;keys&#039;,&#039;twig_get_array_keys_filter&#039;),
new Twig_SimpleFilter(&#039;escape&#039;,&#039;twig_escape_filter&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe_callback&#039;=&gt;&#039;twig_escape_filter_is_safe&#039;)),
new Twig_SimpleFilter(&#039;e&#039;,&#039;twig_escape_filter&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe_callback&#039;=&gt;&#039;twig_escape_filter_is_safe&#039;)),
);
if (function_exists(&#039;mb_get_info&#039;)) {
$filters[] = new Twig_SimpleFilter(&#039;upper&#039;,&#039;twig_upper_filter&#039;, array(&#039;needs_environment&#039;=&gt; true));
$filters[] = new Twig_SimpleFilter(&#039;lower&#039;,&#039;twig_lower_filter&#039;, array(&#039;needs_environment&#039;=&gt; true));
}
return $filters;
}
public function getFunctions()
{
return array(
new Twig_SimpleFunction(&#039;max&#039;,&#039;max&#039;),
new Twig_SimpleFunction(&#039;min&#039;,&#039;min&#039;),
new Twig_SimpleFunction(&#039;range&#039;,&#039;range&#039;),
new Twig_SimpleFunction(&#039;constant&#039;,&#039;twig_constant&#039;),
new Twig_SimpleFunction(&#039;cycle&#039;,&#039;twig_cycle&#039;),
new Twig_SimpleFunction(&#039;random&#039;,&#039;twig_random&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFunction(&#039;date&#039;,&#039;twig_date_converter&#039;, array(&#039;needs_environment&#039;=&gt; true)),
new Twig_SimpleFunction(&#039;include&#039;,&#039;twig_include&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;needs_context&#039;=&gt; true,&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
new Twig_SimpleFunction(&#039;source&#039;,&#039;twig_source&#039;, array(&#039;needs_environment&#039;=&gt; true,&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
);
}
public function getTests()
{
return array(
new Twig_SimpleTest(&#039;even&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Even&#039;)),
new Twig_SimpleTest(&#039;odd&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Odd&#039;)),
new Twig_SimpleTest(&#039;defined&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Defined&#039;)),
new Twig_SimpleTest(&#039;sameas&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Sameas&#039;)),
new Twig_SimpleTest(&#039;same as&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Sameas&#039;)),
new Twig_SimpleTest(&#039;none&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Null&#039;)),
new Twig_SimpleTest(&#039;null&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Null&#039;)),
new Twig_SimpleTest(&#039;divisibleby&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Divisibleby&#039;)),
new Twig_SimpleTest(&#039;divisible by&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Divisibleby&#039;)),
new Twig_SimpleTest(&#039;constant&#039;, null, array(&#039;node_class&#039;=&gt;&#039;Twig_Node_Expression_Test_Constant&#039;)),
new Twig_SimpleTest(&#039;empty&#039;,&#039;twig_test_empty&#039;),
new Twig_SimpleTest(&#039;iterable&#039;,&#039;twig_test_iterable&#039;),
);
}
public function getOperators()
{
return array(
array(&#039;not&#039;=&gt; array(&#039;precedence&#039;=&gt; 50,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Not&#039;),&#039;-&#039;=&gt; array(&#039;precedence&#039;=&gt; 500,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Neg&#039;),&#039;+&#039;=&gt; array(&#039;precedence&#039;=&gt; 500,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Unary_Pos&#039;),
),
array(&#039;or&#039;=&gt; array(&#039;precedence&#039;=&gt; 10,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Or&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;and&#039;=&gt; array(&#039;precedence&#039;=&gt; 15,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_And&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-or&#039;=&gt; array(&#039;precedence&#039;=&gt; 16,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseOr&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-xor&#039;=&gt; array(&#039;precedence&#039;=&gt; 17,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseXor&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;b-and&#039;=&gt; array(&#039;precedence&#039;=&gt; 18,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_BitwiseAnd&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;==&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Equal&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;!=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_NotEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&lt;&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Less&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&gt;&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Greater&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&gt;=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_GreaterEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;&lt;=&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_LessEqual&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;not in&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_NotIn&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;in&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_In&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;matches&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Matches&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;starts with&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_StartsWith&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;ends with&#039;=&gt; array(&#039;precedence&#039;=&gt; 20,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_EndsWith&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;..&#039;=&gt; array(&#039;precedence&#039;=&gt; 25,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Range&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;+&#039;=&gt; array(&#039;precedence&#039;=&gt; 30,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Add&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;-&#039;=&gt; array(&#039;precedence&#039;=&gt; 30,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Sub&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;~&#039;=&gt; array(&#039;precedence&#039;=&gt; 40,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Concat&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;*&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Mul&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;/&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Div&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;//&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_FloorDiv&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;%&#039;=&gt; array(&#039;precedence&#039;=&gt; 60,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Mod&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;is&#039;=&gt; array(&#039;precedence&#039;=&gt; 100,&#039;callable&#039;=&gt; array($this,&#039;parseTestExpression&#039;),&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;is not&#039;=&gt; array(&#039;precedence&#039;=&gt; 100,&#039;callable&#039;=&gt; array($this,&#039;parseNotTestExpression&#039;),&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_LEFT),&#039;**&#039;=&gt; array(&#039;precedence&#039;=&gt; 200,&#039;class&#039;=&gt;&#039;Twig_Node_Expression_Binary_Power&#039;,&#039;associativity&#039;=&gt; Twig_ExpressionParser::OPERATOR_RIGHT),
),
);
}
public function parseNotTestExpression(Twig_Parser $parser, Twig_NodeInterface $node)
{
return new Twig_Node_Expression_Unary_Not($this-&gt;parseTestExpression($parser, $node), $parser-&gt;getCurrentToken()-&gt;getLine());
}
public function parseTestExpression(Twig_Parser $parser, Twig_NodeInterface $node)
{
$stream = $parser-&gt;getStream();
$name = $stream-&gt;expect(Twig_Token::NAME_TYPE)-&gt;getValue();
$class = $this-&gt;getTestNodeClass($parser, $name, $node-&gt;getLine());
$arguments = null;
if ($stream-&gt;test(Twig_Token::PUNCTUATION_TYPE,&#039;(&#039;)) {
$arguments = $parser-&gt;getExpressionParser()-&gt;parseArguments(true);
}
return new $class($node, $name, $arguments, $parser-&gt;getCurrentToken()-&gt;getLine());
}
protected function getTestNodeClass(Twig_Parser $parser, $name, $line)
{
$env = $parser-&gt;getEnvironment();
$testMap = $env-&gt;getTests();
$testName = null;
if (isset($testMap[$name])) {
$testName = $name;
} elseif ($parser-&gt;getStream()-&gt;test(Twig_Token::NAME_TYPE)) {
$name = $name.&#039; &#039;.$parser-&gt;getCurrentToken()-&gt;getValue();
if (isset($testMap[$name])) {
$parser-&gt;getStream()-&gt;next();
$testName = $name;
}
}
if (null === $testName) {
$message = sprintf(&#039;The test &quot;%s&quot; does not exist&#039;, $name);
if ($alternatives = $env-&gt;computeAlternatives($name, array_keys($env-&gt;getTests()))) {
$message = sprintf(&#039;%s. Did you mean &quot;%s&quot;&#039;, $message, implode(&#039;&quot;, &quot;&#039;, $alternatives));
}
throw new Twig_Error_Syntax($message, $line, $parser-&gt;getFilename());
}
if ($testMap[$name] instanceof Twig_SimpleTest) {
return $testMap[$name]-&gt;getNodeClass();
}
return $testMap[$name] instanceof Twig_Test_Node ? $testMap[$name]-&gt;getClass() :&#039;Twig_Node_Expression_Test&#039;;
}
public function getName()
{
return&#039;core&#039;;
}
}
function twig_cycle($values, $position)
{
if (!is_array($values) &amp;&amp; !$values instanceof ArrayAccess) {
return $values;
}
return $values[$position % count($values)];
}
function twig_random(Twig_Environment $env, $values = null)
{
if (null === $values) {
return mt_rand();
}
if (is_int($values) || is_float($values)) {
return $values &lt; 0 ? mt_rand($values, 0) : mt_rand(0, $values);
}
if ($values instanceof Traversable) {
$values = iterator_to_array($values);
} elseif (is_string($values)) {
if (&#039;&#039;=== $values) {
return&#039;&#039;;
}
if (null !== $charset = $env-&gt;getCharset()) {
if (&#039;UTF-8&#039;!= $charset) {
$values = twig_convert_encoding($values,&#039;UTF-8&#039;, $charset);
}
$values = preg_split(&#039;/(?&lt;!^)(?!$)/u&#039;, $values);
if (&#039;UTF-8&#039;!= $charset) {
foreach ($values as $i =&gt; $value) {
$values[$i] = twig_convert_encoding($value, $charset,&#039;UTF-8&#039;);
}
}
} else {
return $values[mt_rand(0, strlen($values) - 1)];
}
}
if (!is_array($values)) {
return $values;
}
if (0 === count($values)) {
throw new Twig_Error_Runtime(&#039;The random function cannot pick from an empty array.&#039;);
}
return $values[array_rand($values, 1)];
}
function twig_date_format_filter(Twig_Environment $env, $date, $format = null, $timezone = null)
{
if (null === $format) {
$formats = $env-&gt;getExtension(&#039;core&#039;)-&gt;getDateFormat();
$format = $date instanceof DateInterval ? $formats[1] : $formats[0];
}
if ($date instanceof DateInterval) {
return $date-&gt;format($format);
}
return twig_date_converter($env, $date, $timezone)-&gt;format($format);
}
function twig_date_modify_filter(Twig_Environment $env, $date, $modifier)
{
$date = twig_date_converter($env, $date, false);
$date-&gt;modify($modifier);
return $date;
}
function twig_date_converter(Twig_Environment $env, $date = null, $timezone = null)
{
if (!$timezone) {
$defaultTimezone = $env-&gt;getExtension(&#039;core&#039;)-&gt;getTimezone();
} elseif (!$timezone instanceof DateTimeZone) {
$defaultTimezone = new DateTimeZone($timezone);
} else {
$defaultTimezone = $timezone;
}
if ($date instanceof DateTimeImmutable) {
return false !== $timezone ? $date-&gt;setTimezone($defaultTimezone) : $date;
}
if ($date instanceof DateTime || $date instanceof DateTimeInterface) {
$date = clone $date;
if (false !== $timezone) {
$date-&gt;setTimezone($defaultTimezone);
}
return $date;
}
$asString = (string) $date;
if (ctype_digit($asString) || (!empty($asString) &amp;&amp;&#039;-&#039;=== $asString[0] &amp;&amp; ctype_digit(substr($asString, 1)))) {
$date =&#039;@&#039;.$date;
}
$date = new DateTime($date, $defaultTimezone);
if (false !== $timezone) {
$date-&gt;setTimezone($defaultTimezone);
}
return $date;
}
function twig_round($value, $precision = 0, $method =&#039;common&#039;)
{
if (&#039;common&#039;== $method) {
return round($value, $precision);
}
if (&#039;ceil&#039;!= $method &amp;&amp;&#039;floor&#039;!= $method) {
throw new Twig_Error_Runtime(&#039;The round filter only supports the &quot;common&quot;, &quot;ceil&quot;, and &quot;floor&quot; methods.&#039;);
}
return $method($value * pow(10, $precision)) / pow(10, $precision);
}
function twig_number_format_filter(Twig_Environment $env, $number, $decimal = null, $decimalPoint = null, $thousandSep = null)
{
$defaults = $env-&gt;getExtension(&#039;core&#039;)-&gt;getNumberFormat();
if (null === $decimal) {
$decimal = $defaults[0];
}
if (null === $decimalPoint) {
$decimalPoint = $defaults[1];
}
if (null === $thousandSep) {
$thousandSep = $defaults[2];
}
return number_format((float) $number, $decimal, $decimalPoint, $thousandSep);
}
function twig_urlencode_filter($url, $raw = false)
{
if (is_array($url)) {
return http_build_query($url,&#039;&#039;,&#039;&amp;&#039;);
}
if ($raw) {
return rawurlencode($url);
}
return urlencode($url);
}
if (version_compare(PHP_VERSION,&#039;5.3.0&#039;,&#039;&lt;&#039;)) {
function twig_jsonencode_filter($value, $options = 0)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
} elseif (is_array($value)) {
array_walk_recursive($value,&#039;_twig_markup2string&#039;);
}
return json_encode($value);
}
} else {
function twig_jsonencode_filter($value, $options = 0)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
} elseif (is_array($value)) {
array_walk_recursive($value,&#039;_twig_markup2string&#039;);
}
return json_encode($value, $options);
}
}
function _twig_markup2string(&amp;$value)
{
if ($value instanceof Twig_Markup) {
$value = (string) $value;
}
}
function twig_array_merge($arr1, $arr2)
{
if (!is_array($arr1) || !is_array($arr2)) {
throw new Twig_Error_Runtime(&#039;The merge filter only works with arrays or hashes.&#039;);
}
return array_merge($arr1, $arr2);
}
function twig_slice(Twig_Environment $env, $item, $start, $length = null, $preserveKeys = false)
{
if ($item instanceof Traversable) {
$item = iterator_to_array($item, false);
}
if (is_array($item)) {
return array_slice($item, $start, $length, $preserveKeys);
}
$item = (string) $item;
if (function_exists(&#039;mb_get_info&#039;) &amp;&amp; null !== $charset = $env-&gt;getCharset()) {
return mb_substr($item, $start, null === $length ? mb_strlen($item, $charset) - $start : $length, $charset);
}
return null === $length ? substr($item, $start) : substr($item, $start, $length);
}
function twig_first(Twig_Environment $env, $item)
{
$elements = twig_slice($env, $item, 0, 1, false);
return is_string($elements) ? $elements : current($elements);
}
function twig_last(Twig_Environment $env, $item)
{
$elements = twig_slice($env, $item, -1, 1, false);
return is_string($elements) ? $elements : current($elements);
}
function twig_join_filter($value, $glue =&#039;&#039;)
{
if ($value instanceof Traversable) {
$value = iterator_to_array($value, false);
}
return implode($glue, (array) $value);
}
function twig_split_filter($value, $delimiter, $limit = null)
{
if (empty($delimiter)) {
return str_split($value, null === $limit ? 1 : $limit);
}
return null === $limit ? explode($delimiter, $value) : explode($delimiter, $value, $limit);
}
function _twig_default_filter($value, $default =&#039;&#039;)
{
if (twig_test_empty($value)) {
return $default;
}
return $value;
}
function twig_get_array_keys_filter($array)
{
if (is_object($array) &amp;&amp; $array instanceof Traversable) {
return array_keys(iterator_to_array($array));
}
if (!is_array($array)) {
return array();
}
return array_keys($array);
}
function twig_reverse_filter(Twig_Environment $env, $item, $preserveKeys = false)
{
if (is_object($item) &amp;&amp; $item instanceof Traversable) {
return array_reverse(iterator_to_array($item), $preserveKeys);
}
if (is_array($item)) {
return array_reverse($item, $preserveKeys);
}
if (null !== $charset = $env-&gt;getCharset()) {
$string = (string) $item;
if (&#039;UTF-8&#039;!= $charset) {
$item = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
preg_match_all(&#039;/./us&#039;, $item, $matches);
$string = implode(&#039;&#039;, array_reverse($matches[0]));
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
}
return strrev((string) $item);
}
function twig_sort_filter($array)
{
asort($array);
return $array;
}
function twig_in_filter($value, $compare)
{
if (is_array($compare)) {
return in_array($value, $compare, is_object($value));
} elseif (is_string($compare)) {
if (!strlen($value)) {
return empty($compare);
}
return false !== strpos($compare, (string) $value);
} elseif ($compare instanceof Traversable) {
return in_array($value, iterator_to_array($compare, false), is_object($value));
}
return false;
}
function twig_escape_filter(Twig_Environment $env, $string, $strategy =&#039;html&#039;, $charset = null, $autoescape = false)
{
if ($autoescape &amp;&amp; $string instanceof Twig_Markup) {
return $string;
}
if (!is_string($string)) {
if (is_object($string) &amp;&amp; method_exists($string,&#039;__toString&#039;)) {
$string = (string) $string;
} else {
return $string;
}
}
if (null === $charset) {
$charset = $env-&gt;getCharset();
}
switch ($strategy) {
case&#039;html&#039;:
static $htmlspecialcharsCharsets;
if (null === $htmlspecialcharsCharsets) {
if (&#039;hiphop&#039;=== substr(PHP_VERSION, -6)) {
$htmlspecialcharsCharsets = array(&#039;utf-8&#039;=&gt; true,&#039;UTF-8&#039;=&gt; true);
} else {
$htmlspecialcharsCharsets = array(&#039;ISO-8859-1&#039;=&gt; true,&#039;ISO8859-1&#039;=&gt; true,&#039;ISO-8859-15&#039;=&gt; true,&#039;ISO8859-15&#039;=&gt; true,&#039;utf-8&#039;=&gt; true,&#039;UTF-8&#039;=&gt; true,&#039;CP866&#039;=&gt; true,&#039;IBM866&#039;=&gt; true,&#039;866&#039;=&gt; true,&#039;CP1251&#039;=&gt; true,&#039;WINDOWS-1251&#039;=&gt; true,&#039;WIN-1251&#039;=&gt; true,&#039;1251&#039;=&gt; true,&#039;CP1252&#039;=&gt; true,&#039;WINDOWS-1252&#039;=&gt; true,&#039;1252&#039;=&gt; true,&#039;KOI8-R&#039;=&gt; true,&#039;KOI8-RU&#039;=&gt; true,&#039;KOI8R&#039;=&gt; true,&#039;BIG5&#039;=&gt; true,&#039;950&#039;=&gt; true,&#039;GB2312&#039;=&gt; true,&#039;936&#039;=&gt; true,&#039;BIG5-HKSCS&#039;=&gt; true,&#039;SHIFT_JIS&#039;=&gt; true,&#039;SJIS&#039;=&gt; true,&#039;932&#039;=&gt; true,&#039;EUC-JP&#039;=&gt; true,&#039;EUCJP&#039;=&gt; true,&#039;ISO8859-5&#039;=&gt; true,&#039;ISO-8859-5&#039;=&gt; true,&#039;MACROMAN&#039;=&gt; true,
);
}
}
if (isset($htmlspecialcharsCharsets[$charset])) {
return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
}
if (isset($htmlspecialcharsCharsets[strtoupper($charset)])) {
$htmlspecialcharsCharsets[$charset] = true;
return htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE, $charset);
}
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
$string = htmlspecialchars($string, ENT_QUOTES | ENT_SUBSTITUTE,&#039;UTF-8&#039;);
return twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
case&#039;js&#039;:
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9,\._]#Su&#039;,&#039;_twig_escape_js_callback&#039;, $string);
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;css&#039;:
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9]#Su&#039;,&#039;_twig_escape_css_callback&#039;, $string);
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;html_attr&#039;:
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string,&#039;UTF-8&#039;, $charset);
}
if (0 == strlen($string) ? false : (1 == preg_match(&#039;/^./su&#039;, $string) ? false : true)) {
throw new Twig_Error_Runtime(&#039;The string to escape is not a valid UTF-8 string.&#039;);
}
$string = preg_replace_callback(&#039;#[^a-zA-Z0-9,\.\-_]#Su&#039;,&#039;_twig_escape_html_attr_callback&#039;, $string);
if (&#039;UTF-8&#039;!= $charset) {
$string = twig_convert_encoding($string, $charset,&#039;UTF-8&#039;);
}
return $string;
case&#039;url&#039;:
if (PHP_VERSION &lt;&#039;5.3.0&#039;) {
return str_replace(&#039;%7E&#039;,&#039;~&#039;, rawurlencode($string));
}
return rawurlencode($string);
default:
static $escapers;
if (null === $escapers) {
$escapers = $env-&gt;getExtension(&#039;core&#039;)-&gt;getEscapers();
}
if (isset($escapers[$strategy])) {
return call_user_func($escapers[$strategy], $env, $string, $charset);
}
$validStrategies = implode(&#039;, &#039;, array_merge(array(&#039;html&#039;,&#039;js&#039;,&#039;url&#039;,&#039;css&#039;,&#039;html_attr&#039;), array_keys($escapers)));
throw new Twig_Error_Runtime(sprintf(&#039;Invalid escaping strategy &quot;%s&quot; (valid ones: %s).&#039;, $strategy, $validStrategies));
}
}
function twig_escape_filter_is_safe(Twig_Node $filterArgs)
{
foreach ($filterArgs as $arg) {
if ($arg instanceof Twig_Node_Expression_Constant) {
return array($arg-&gt;getAttribute(&#039;value&#039;));
}
return array();
}
return array(&#039;html&#039;);
}
if (function_exists(&#039;mb_convert_encoding&#039;)) {
function twig_convert_encoding($string, $to, $from)
{
return mb_convert_encoding($string, $to, $from);
}
} elseif (function_exists(&#039;iconv&#039;)) {
function twig_convert_encoding($string, $to, $from)
{
return iconv($from, $to, $string);
}
} else {
function twig_convert_encoding($string, $to, $from)
{
throw new Twig_Error_Runtime(&#039;No suitable convert encoding function (use UTF-8 as your encoding or install the iconv or mbstring extension).&#039;);
}
}
function _twig_escape_js_callback($matches)
{
$char = $matches[0];
if (!isset($char[1])) {
return&#039;\\x&#039;.strtoupper(substr(&#039;00&#039;.bin2hex($char), -2));
}
$char = twig_convert_encoding($char,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
return&#039;\\u&#039;.strtoupper(substr(&#039;0000&#039;.bin2hex($char), -4));
}
function _twig_escape_css_callback($matches)
{
$char = $matches[0];
if (!isset($char[1])) {
$hex = ltrim(strtoupper(bin2hex($char)),&#039;0&#039;);
if (0 === strlen($hex)) {
$hex =&#039;0&#039;;
}
return&#039;\\&#039;.$hex.&#039; &#039;;
}
$char = twig_convert_encoding($char,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
return&#039;\\&#039;.ltrim(strtoupper(bin2hex($char)),&#039;0&#039;).&#039; &#039;;
}
function _twig_escape_html_attr_callback($matches)
{
static $entityMap = array(
34 =&gt;&#039;quot&#039;,
38 =&gt;&#039;amp&#039;,
60 =&gt;&#039;lt&#039;,
62 =&gt;&#039;gt&#039;,
);
$chr = $matches[0];
$ord = ord($chr);
if (($ord &lt;= 0x1f &amp;&amp; $chr !=&quot;\t&quot;&amp;&amp; $chr !=&quot;\n&quot;&amp;&amp; $chr !=&quot;\r&quot;) || ($ord &gt;= 0x7f &amp;&amp; $ord &lt;= 0x9f)) {
return&#039;&amp;#xFFFD;&#039;;
}
if (strlen($chr) == 1) {
$hex = strtoupper(substr(&#039;00&#039;.bin2hex($chr), -2));
} else {
$chr = twig_convert_encoding($chr,&#039;UTF-16BE&#039;,&#039;UTF-8&#039;);
$hex = strtoupper(substr(&#039;0000&#039;.bin2hex($chr), -4));
}
$int = hexdec($hex);
if (array_key_exists($int, $entityMap)) {
return sprintf(&#039;&amp;%s;&#039;, $entityMap[$int]);
}
return sprintf(&#039;&amp;#x%s;&#039;, $hex);
}
if (function_exists(&#039;mb_get_info&#039;)) {
function twig_length_filter(Twig_Environment $env, $thing)
{
return is_scalar($thing) ? mb_strlen($thing, $env-&gt;getCharset()) : count($thing);
}
function twig_upper_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_strtoupper($string, $charset);
}
return strtoupper($string);
}
function twig_lower_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_strtolower($string, $charset);
}
return strtolower($string);
}
function twig_title_string_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_convert_case($string, MB_CASE_TITLE, $charset);
}
return ucwords(strtolower($string));
}
function twig_capitalize_string_filter(Twig_Environment $env, $string)
{
if (null !== ($charset = $env-&gt;getCharset())) {
return mb_strtoupper(mb_substr($string, 0, 1, $charset), $charset).
mb_strtolower(mb_substr($string, 1, mb_strlen($string, $charset), $charset), $charset);
}
return ucfirst(strtolower($string));
}
}
else {
function twig_length_filter(Twig_Environment $env, $thing)
{
return is_scalar($thing) ? strlen($thing) : count($thing);
}
function twig_title_string_filter(Twig_Environment $env, $string)
{
return ucwords(strtolower($string));
}
function twig_capitalize_string_filter(Twig_Environment $env, $string)
{
return ucfirst(strtolower($string));
}
}
function twig_ensure_traversable($seq)
{
if ($seq instanceof Traversable || is_array($seq)) {
return $seq;
}
return array();
}
function twig_test_empty($value)
{
if ($value instanceof Countable) {
return 0 == count($value);
}
return&#039;&#039;=== $value || false === $value || null === $value || array() === $value;
}
function twig_test_iterable($value)
{
return $value instanceof Traversable || is_array($value);
}
function twig_include(Twig_Environment $env, $context, $template, $variables = array(), $withContext = true, $ignoreMissing = false, $sandboxed = false)
{
$alreadySandboxed = false;
$sandbox = null;
if ($withContext) {
$variables = array_merge($context, $variables);
}
if ($isSandboxed = $sandboxed &amp;&amp; $env-&gt;hasExtension(&#039;sandbox&#039;)) {
$sandbox = $env-&gt;getExtension(&#039;sandbox&#039;);
if (!$alreadySandboxed = $sandbox-&gt;isSandboxed()) {
$sandbox-&gt;enableSandbox();
}
}
try {
return $env-&gt;resolveTemplate($template)-&gt;render($variables);
} catch (Twig_Error_Loader $e) {
if (!$ignoreMissing) {
throw $e;
}
}
if ($isSandboxed &amp;&amp; !$alreadySandboxed) {
$sandbox-&gt;disableSandbox();
}
}
function twig_source(Twig_Environment $env, $name)
{
return $env-&gt;getLoader()-&gt;getSource($name);
}
function twig_constant($constant, $object = null)
{
if (null !== $object) {
$constant = get_class($object).&#039;::&#039;.$constant;
}
return constant($constant);
}
function twig_array_batch($items, $size, $fill = null)
{
if ($items instanceof Traversable) {
$items = iterator_to_array($items, false);
}
$size = ceil($size);
$result = array_chunk($items, $size, true);
if (null !== $fill) {
$last = count($result) - 1;
if ($fillCount = $size - count($result[$last])) {
$result[$last] = array_merge(
$result[$last],
array_fill(0, $fillCount, $fill)
);
}
}
return $result;
}
}
namespace
{
class Twig_Extension_Escaper extends Twig_Extension
{
protected $defaultStrategy;
public function __construct($defaultStrategy =&#039;html&#039;)
{
$this-&gt;setDefaultStrategy($defaultStrategy);
}
public function getTokenParsers()
{
return array(new Twig_TokenParser_AutoEscape());
}
public function getNodeVisitors()
{
return array(new Twig_NodeVisitor_Escaper());
}
public function getFilters()
{
return array(
new Twig_SimpleFilter(&#039;raw&#039;,&#039;twig_raw_filter&#039;, array(&#039;is_safe&#039;=&gt; array(&#039;all&#039;))),
);
}
public function setDefaultStrategy($defaultStrategy)
{
if (true === $defaultStrategy) {
$defaultStrategy =&#039;html&#039;;
}
$this-&gt;defaultStrategy = $defaultStrategy;
}
public function getDefaultStrategy($filename)
{
if (!is_string($this-&gt;defaultStrategy) &amp;&amp; is_callable($this-&gt;defaultStrategy)) {
return call_user_func($this-&gt;defaultStrategy, $filename);
}
return $this-&gt;defaultStrategy;
}
public function getName()
{
return&#039;escaper&#039;;
}
}
function twig_raw_filter($string)
{
return $string;
}
}
namespace
{
class Twig_Extension_Optimizer extends Twig_Extension
{
protected $optimizers;
public function __construct($optimizers = -1)
{
$this-&gt;optimizers = $optimizers;
}
public function getNodeVisitors()
{
return array(new Twig_NodeVisitor_Optimizer($this-&gt;optimizers));
}
public function getName()
{
return&#039;optimizer&#039;;
}
}
}
namespace
{
interface Twig_LoaderInterface
{
public function getSource($name);
public function getCacheKey($name);
public function isFresh($name, $time);
}
}
namespace
{
class Twig_Markup implements Countable
{
protected $content;
protected $charset;
public function __construct($content, $charset)
{
$this-&gt;content = (string) $content;
$this-&gt;charset = $charset;
}
public function __toString()
{
return $this-&gt;content;
}
public function count()
{
return function_exists(&#039;mb_get_info&#039;) ? mb_strlen($this-&gt;content, $this-&gt;charset) : strlen($this-&gt;content);
}
}
}
namespace
{
interface Twig_TemplateInterface
{
const ANY_CALL =&#039;any&#039;;
const ARRAY_CALL =&#039;array&#039;;
const METHOD_CALL =&#039;method&#039;;
public function render(array $context);
public function display(array $context, array $blocks = array());
public function getEnvironment();
}
}
namespace
{
abstract class Twig_Template implements Twig_TemplateInterface
{
protected static $cache = array();
protected $parent;
protected $parents;
protected $env;
protected $blocks;
protected $traits;
public function __construct(Twig_Environment $env)
{
$this-&gt;env = $env;
$this-&gt;blocks = array();
$this-&gt;traits = array();
}
abstract public function getTemplateName();
public function getEnvironment()
{
return $this-&gt;env;
}
public function getParent(array $context)
{
if (null !== $this-&gt;parent) {
return $this-&gt;parent;
}
$parent = $this-&gt;doGetParent($context);
if (false === $parent) {
return false;
} elseif ($parent instanceof Twig_Template) {
$name = $parent-&gt;getTemplateName();
$this-&gt;parents[$name] = $parent;
$parent = $name;
} elseif (!isset($this-&gt;parents[$parent])) {
$this-&gt;parents[$parent] = $this-&gt;env-&gt;loadTemplate($parent);
}
return $this-&gt;parents[$parent];
}
protected function doGetParent(array $context)
{
return false;
}
public function isTraitable()
{
return true;
}
public function displayParentBlock($name, array $context, array $blocks = array())
{
$name = (string) $name;
if (isset($this-&gt;traits[$name])) {
$this-&gt;traits[$name][0]-&gt;displayBlock($name, $context, $blocks);
} elseif (false !== $parent = $this-&gt;getParent($context)) {
$parent-&gt;displayBlock($name, $context, $blocks);
} else {
throw new Twig_Error_Runtime(sprintf(&#039;The template has no parent and no traits defining the &quot;%s&quot; block&#039;, $name), -1, $this-&gt;getTemplateName());
}
}
public function displayBlock($name, array $context, array $blocks = array())
{
$name = (string) $name;
if (isset($blocks[$name])) {
$template = $blocks[$name][0];
$block = $blocks[$name][1];
unset($blocks[$name]);
} elseif (isset($this-&gt;blocks[$name])) {
$template = $this-&gt;blocks[$name][0];
$block = $this-&gt;blocks[$name][1];
} else {
$template = null;
$block = null;
}
if (null !== $template) {
try {
$template-&gt;$block($context, $blocks);
} catch (Twig_Error $e) {
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Runtime(sprintf(&#039;An exception has been thrown during the rendering of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $template-&gt;getTemplateName(), $e);
}
} elseif (false !== $parent = $this-&gt;getParent($context)) {
$parent-&gt;displayBlock($name, $context, array_merge($this-&gt;blocks, $blocks));
}
}
public function renderParentBlock($name, array $context, array $blocks = array())
{
ob_start();
$this-&gt;displayParentBlock($name, $context, $blocks);
return ob_get_clean();
}
public function renderBlock($name, array $context, array $blocks = array())
{
ob_start();
$this-&gt;displayBlock($name, $context, $blocks);
return ob_get_clean();
}
public function hasBlock($name)
{
return isset($this-&gt;blocks[(string) $name]);
}
public function getBlockNames()
{
return array_keys($this-&gt;blocks);
}
public function getBlocks()
{
return $this-&gt;blocks;
}
public function display(array $context, array $blocks = array())
{
$this-&gt;displayWithErrorHandling($this-&gt;env-&gt;mergeGlobals($context), $blocks);
}
public function render(array $context)
{
$level = ob_get_level();
ob_start();
try {
$this-&gt;display($context);
} catch (Exception $e) {
while (ob_get_level() &gt; $level) {
ob_end_clean();
}
throw $e;
}
return ob_get_clean();
}
protected function displayWithErrorHandling(array $context, array $blocks = array())
{
try {
$this-&gt;doDisplay($context, $blocks);
} catch (Twig_Error $e) {
if (!$e-&gt;getTemplateFile()) {
$e-&gt;setTemplateFile($this-&gt;getTemplateName());
}
if (false === $e-&gt;getTemplateLine()) {
$e-&gt;setTemplateLine(-1);
$e-&gt;guess();
}
throw $e;
} catch (Exception $e) {
throw new Twig_Error_Runtime(sprintf(&#039;An exception has been thrown during the rendering of a template (&quot;%s&quot;).&#039;, $e-&gt;getMessage()), -1, $this-&gt;getTemplateName(), $e);
}
}
abstract protected function doDisplay(array $context, array $blocks = array());
final protected function getContext($context, $item, $ignoreStrictCheck = false)
{
if (!array_key_exists($item, $context)) {
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
throw new Twig_Error_Runtime(sprintf(&#039;Variable &quot;%s&quot; does not exist&#039;, $item), -1, $this-&gt;getTemplateName());
}
return $context[$item];
}
protected function getAttribute($object, $item, array $arguments = array(), $type = Twig_Template::ANY_CALL, $isDefinedTest = false, $ignoreStrictCheck = false)
{
if (Twig_Template::METHOD_CALL !== $type) {
$arrayItem = is_bool($item) || is_float($item) ? (int) $item : $item;
if ((is_array($object) &amp;&amp; array_key_exists($arrayItem, $object))
|| ($object instanceof ArrayAccess &amp;&amp; isset($object[$arrayItem]))
) {
if ($isDefinedTest) {
return true;
}
return $object[$arrayItem];
}
if (Twig_Template::ARRAY_CALL === $type || !is_object($object)) {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
if ($object instanceof ArrayAccess) {
$message = sprintf(&#039;Key &quot;%s&quot; in object with ArrayAccess of class &quot;%s&quot; does not exist&#039;, $arrayItem, get_class($object));
} elseif (is_object($object)) {
$message = sprintf(&#039;Impossible to access a key &quot;%s&quot; on an object of class &quot;%s&quot; that does not implement ArrayAccess interface&#039;, $item, get_class($object));
} elseif (is_array($object)) {
$message = sprintf(&#039;Key &quot;%s&quot; for array with keys &quot;%s&quot; does not exist&#039;, $arrayItem, implode(&#039;, &#039;, array_keys($object)));
} elseif (Twig_Template::ARRAY_CALL === $type) {
$message = sprintf(&#039;Impossible to access a key (&quot;%s&quot;) on a %s variable (&quot;%s&quot;)&#039;, $item, gettype($object), $object);
} else {
$message = sprintf(&#039;Impossible to access an attribute (&quot;%s&quot;) on a %s variable (&quot;%s&quot;)&#039;, $item, gettype($object), $object);
}
throw new Twig_Error_Runtime($message, -1, $this-&gt;getTemplateName());
}
}
if (!is_object($object)) {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
throw new Twig_Error_Runtime(sprintf(&#039;Impossible to invoke a method (&quot;%s&quot;) on a %s variable (&quot;%s&quot;)&#039;, $item, gettype($object), $object), -1, $this-&gt;getTemplateName());
}
$class = get_class($object);
if (Twig_Template::METHOD_CALL !== $type) {
if (isset($object-&gt;$item) || array_key_exists((string) $item, $object)) {
if ($isDefinedTest) {
return true;
}
if ($this-&gt;env-&gt;hasExtension(&#039;sandbox&#039;)) {
$this-&gt;env-&gt;getExtension(&#039;sandbox&#039;)-&gt;checkPropertyAllowed($object, $item);
}
return $object-&gt;$item;
}
}
if (!isset(self::$cache[$class][&#039;methods&#039;])) {
self::$cache[$class][&#039;methods&#039;] = array_change_key_case(array_flip(get_class_methods($object)));
}
$call = false;
$lcItem = strtolower($item);
if (isset(self::$cache[$class][&#039;methods&#039;][$lcItem])) {
$method = (string) $item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;get&#039;.$lcItem])) {
$method =&#039;get&#039;.$item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;is&#039;.$lcItem])) {
$method =&#039;is&#039;.$item;
} elseif (isset(self::$cache[$class][&#039;methods&#039;][&#039;__call&#039;])) {
$method = (string) $item;
$call = true;
} else {
if ($isDefinedTest) {
return false;
}
if ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables()) {
return null;
}
throw new Twig_Error_Runtime(sprintf(&#039;Method &quot;%s&quot; for object &quot;%s&quot; does not exist&#039;, $item, get_class($object)), -1, $this-&gt;getTemplateName());
}
if ($isDefinedTest) {
return true;
}
if ($this-&gt;env-&gt;hasExtension(&#039;sandbox&#039;)) {
$this-&gt;env-&gt;getExtension(&#039;sandbox&#039;)-&gt;checkMethodAllowed($object, $method);
}
try {
$ret = call_user_func_array(array($object, $method), $arguments);
} catch (BadMethodCallException $e) {
if ($call &amp;&amp; ($ignoreStrictCheck || !$this-&gt;env-&gt;isStrictVariables())) {
return null;
}
throw $e;
}
if ($object instanceof Twig_TemplateInterface) {
return $ret ===&#039;&#039;?&#039;&#039;: new Twig_Markup($ret, $this-&gt;env-&gt;getCharset());
}
return $ret;
}
public static function clearCache()
{
self::$cache = array();
}
}
}
namespace Monolog\Formatter
{
interface FormatterInterface
{
public function format(array $record);
public function formatBatch(array $records);
}
}
namespace Monolog\Formatter
{
use Exception;
class NormalizerFormatter implements FormatterInterface
{
const SIMPLE_DATE =&quot;Y-m-d H:i:s&quot;;
protected $dateFormat;
public function __construct($dateFormat = null)
{
$this-&gt;dateFormat = $dateFormat ?: static::SIMPLE_DATE;
}
public function format(array $record)
{
return $this-&gt;normalize($record);
}
public function formatBatch(array $records)
{
foreach ($records as $key =&gt; $record) {
$records[$key] = $this-&gt;format($record);
}
return $records;
}
protected function normalize($data)
{
if (null === $data || is_scalar($data)) {
return $data;
}
if (is_array($data) || $data instanceof \Traversable) {
$normalized = array();
$count = 1;
foreach ($data as $key =&gt; $value) {
if ($count++ &gt;= 1000) {
$normalized[&#039;...&#039;] =&#039;Over 1000 items, aborting normalization&#039;;
break;
}
$normalized[$key] = $this-&gt;normalize($value);
}
return $normalized;
}
if ($data instanceof \DateTime) {
return $data-&gt;format($this-&gt;dateFormat);
}
if (is_object($data)) {
if ($data instanceof Exception) {
return $this-&gt;normalizeException($data);
}
return sprintf(&quot;[object] (%s: %s)&quot;, get_class($data), $this-&gt;toJson($data, true));
}
if (is_resource($data)) {
return&#039;[resource]&#039;;
}
return&#039;[unknown(&#039;.gettype($data).&#039;)]&#039;;
}
protected function normalizeException(Exception $e)
{
$data = array(&#039;class&#039;=&gt; get_class($e),&#039;message&#039;=&gt; $e-&gt;getMessage(),&#039;file&#039;=&gt; $e-&gt;getFile().&#039;:&#039;.$e-&gt;getLine(),
);
$trace = $e-&gt;getTrace();
array_shift($trace);
foreach ($trace as $frame) {
if (isset($frame[&#039;file&#039;])) {
$data[&#039;trace&#039;][] = $frame[&#039;file&#039;].&#039;:&#039;.$frame[&#039;line&#039;];
} else {
$data[&#039;trace&#039;][] = json_encode($frame);
}
}
if ($previous = $e-&gt;getPrevious()) {
$data[&#039;previous&#039;] = $this-&gt;normalizeException($previous);
}
return $data;
}
protected function toJson($data, $ignoreErrors = false)
{
if ($ignoreErrors) {
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return @json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}
return @json_encode($data);
}
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return json_encode($data, JSON_UNESCAPED_SLASHES | JSON_UNESCAPED_UNICODE);
}
return json_encode($data);
}
}
}
namespace Monolog\Formatter
{
class LineFormatter extends NormalizerFormatter
{
const SIMPLE_FORMAT =&quot;[%datetime%] %channel%.%level_name%: %message% %context% %extra%\n&quot;;
protected $format;
public function __construct($format = null, $dateFormat = null)
{
$this-&gt;format = $format ?: static::SIMPLE_FORMAT;
parent::__construct($dateFormat);
}
public function format(array $record)
{
$vars = parent::format($record);
$output = $this-&gt;format;
foreach ($vars[&#039;extra&#039;] as $var =&gt; $val) {
if (false !== strpos($output,&#039;%extra.&#039;.$var.&#039;%&#039;)) {
$output = str_replace(&#039;%extra.&#039;.$var.&#039;%&#039;, $this-&gt;convertToString($val), $output);
unset($vars[&#039;extra&#039;][$var]);
}
}
foreach ($vars as $var =&gt; $val) {
if (false !== strpos($output,&#039;%&#039;.$var.&#039;%&#039;)) {
$output = str_replace(&#039;%&#039;.$var.&#039;%&#039;, $this-&gt;convertToString($val), $output);
}
}
return $output;
}
public function formatBatch(array $records)
{
$message =&#039;&#039;;
foreach ($records as $record) {
$message .= $this-&gt;format($record);
}
return $message;
}
protected function normalize($data)
{
if (is_bool($data) || is_null($data)) {
return var_export($data, true);
}
if ($data instanceof \Exception) {
$previousText =&#039;&#039;;
if ($previous = $data-&gt;getPrevious()) {
do {
$previousText .=&#039;, &#039;.get_class($previous).&#039;: &#039;.$previous-&gt;getMessage().&#039; at &#039;.$previous-&gt;getFile().&#039;:&#039;.$previous-&gt;getLine();
} while ($previous = $previous-&gt;getPrevious());
}
return&#039;[object] (&#039;.get_class($data).&#039;: &#039;.$data-&gt;getMessage().&#039; at &#039;.$data-&gt;getFile().&#039;:&#039;.$data-&gt;getLine().$previousText.&#039;)&#039;;
}
return parent::normalize($data);
}
protected function convertToString($data)
{
if (null === $data || is_scalar($data)) {
return (string) $data;
}
$data = $this-&gt;normalize($data);
if (version_compare(PHP_VERSION,&#039;5.4.0&#039;,&#039;&gt;=&#039;)) {
return $this-&gt;toJson($data, true);
}
return str_replace(&#039;\\/&#039;,&#039;/&#039;, @json_encode($data));
}
}
}
namespace Monolog\Handler
{
use Monolog\Formatter\FormatterInterface;
interface HandlerInterface
{
public function isHandling(array $record);
public function handle(array $record);
public function handleBatch(array $records);
public function pushProcessor($callback);
public function popProcessor();
public function setFormatter(FormatterInterface $formatter);
public function getFormatter();
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
use Monolog\Formatter\FormatterInterface;
use Monolog\Formatter\LineFormatter;
abstract class AbstractHandler implements HandlerInterface
{
protected $level = Logger::DEBUG;
protected $bubble = true;
protected $formatter;
protected $processors = array();
public function __construct($level = Logger::DEBUG, $bubble = true)
{
$this-&gt;level = $level;
$this-&gt;bubble = $bubble;
}
public function isHandling(array $record)
{
return $record[&#039;level&#039;] &gt;= $this-&gt;level;
}
public function handleBatch(array $records)
{
foreach ($records as $record) {
$this-&gt;handle($record);
}
}
public function close()
{
}
public function pushProcessor($callback)
{
if (!is_callable($callback)) {
throw new \InvalidArgumentException(&#039;Processors must be valid callables (callback or object with an __invoke method), &#039;.var_export($callback, true).&#039; given&#039;);
}
array_unshift($this-&gt;processors, $callback);
return $this;
}
public function popProcessor()
{
if (!$this-&gt;processors) {
throw new \LogicException(&#039;You tried to pop from an empty processor stack.&#039;);
}
return array_shift($this-&gt;processors);
}
public function setFormatter(FormatterInterface $formatter)
{
$this-&gt;formatter = $formatter;
return $this;
}
public function getFormatter()
{
if (!$this-&gt;formatter) {
$this-&gt;formatter = $this-&gt;getDefaultFormatter();
}
return $this-&gt;formatter;
}
public function setLevel($level)
{
$this-&gt;level = $level;
return $this;
}
public function getLevel()
{
return $this-&gt;level;
}
public function setBubble($bubble)
{
$this-&gt;bubble = $bubble;
return $this;
}
public function getBubble()
{
return $this-&gt;bubble;
}
public function __destruct()
{
try {
$this-&gt;close();
} catch (\Exception $e) {
}
}
protected function getDefaultFormatter()
{
return new LineFormatter();
}
}
}
namespace Monolog\Handler
{
abstract class AbstractProcessingHandler extends AbstractHandler
{
public function handle(array $record)
{
if (!$this-&gt;isHandling($record)) {
return false;
}
$record = $this-&gt;processRecord($record);
$record[&#039;formatted&#039;] = $this-&gt;getFormatter()-&gt;format($record);
$this-&gt;write($record);
return false === $this-&gt;bubble;
}
abstract protected function write(array $record);
protected function processRecord(array $record)
{
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
return $record;
}
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
class StreamHandler extends AbstractProcessingHandler
{
protected $stream;
protected $url;
private $errorMessage;
public function __construct($stream, $level = Logger::DEBUG, $bubble = true)
{
parent::__construct($level, $bubble);
if (is_resource($stream)) {
$this-&gt;stream = $stream;
} else {
$this-&gt;url = $stream;
}
}
public function close()
{
if (is_resource($this-&gt;stream)) {
fclose($this-&gt;stream);
}
$this-&gt;stream = null;
}
protected function write(array $record)
{
if (null === $this-&gt;stream) {
if (!$this-&gt;url) {
throw new \LogicException(&#039;Missing stream url, the stream can not be opened. This may be caused by a premature call to close().&#039;);
}
$this-&gt;errorMessage = null;
set_error_handler(array($this,&#039;customErrorHandler&#039;));
$this-&gt;stream = fopen($this-&gt;url,&#039;a&#039;);
restore_error_handler();
if (!is_resource($this-&gt;stream)) {
$this-&gt;stream = null;
throw new \UnexpectedValueException(sprintf(&#039;The stream or file &quot;%s&quot; could not be opened: &#039;.$this-&gt;errorMessage, $this-&gt;url));
}
}
fwrite($this-&gt;stream, (string) $record[&#039;formatted&#039;]);
}
private function customErrorHandler($code, $msg) {
$this-&gt;errorMessage = preg_replace(&#039;{^fopen\(.*?\): }&#039;,&#039;&#039;, $msg);
}
}
}
namespace Monolog\Handler
{
use Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy;
use Monolog\Handler\FingersCrossed\ActivationStrategyInterface;
use Monolog\Logger;
class FingersCrossedHandler extends AbstractHandler
{
protected $handler;
protected $activationStrategy;
protected $buffering = true;
protected $bufferSize;
protected $buffer = array();
protected $stopBuffering;
public function __construct($handler, $activationStrategy = null, $bufferSize = 0, $bubble = true, $stopBuffering = true)
{
if (null === $activationStrategy) {
$activationStrategy = new ErrorLevelActivationStrategy(Logger::WARNING);
}
if (!$activationStrategy instanceof ActivationStrategyInterface) {
$activationStrategy = new ErrorLevelActivationStrategy($activationStrategy);
}
$this-&gt;handler = $handler;
$this-&gt;activationStrategy = $activationStrategy;
$this-&gt;bufferSize = $bufferSize;
$this-&gt;bubble = $bubble;
$this-&gt;stopBuffering = $stopBuffering;
}
public function isHandling(array $record)
{
return true;
}
public function handle(array $record)
{
if ($this-&gt;processors) {
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
}
if ($this-&gt;buffering) {
$this-&gt;buffer[] = $record;
if ($this-&gt;bufferSize &gt; 0 &amp;&amp; count($this-&gt;buffer) &gt; $this-&gt;bufferSize) {
array_shift($this-&gt;buffer);
}
if ($this-&gt;activationStrategy-&gt;isHandlerActivated($record)) {
if ($this-&gt;stopBuffering) {
$this-&gt;buffering = false;
}
if (!$this-&gt;handler instanceof HandlerInterface) {
if (!is_callable($this-&gt;handler)) {
throw new \RuntimeException(&quot;The given handler (&quot;.json_encode($this-&gt;handler).&quot;) is not a callable nor a Monolog\Handler\HandlerInterface object&quot;);
}
$this-&gt;handler = call_user_func($this-&gt;handler, $record, $this);
if (!$this-&gt;handler instanceof HandlerInterface) {
throw new \RuntimeException(&quot;The factory callable should return a HandlerInterface&quot;);
}
}
$this-&gt;handler-&gt;handleBatch($this-&gt;buffer);
$this-&gt;buffer = array();
}
} else {
$this-&gt;handler-&gt;handle($record);
}
return false === $this-&gt;bubble;
}
public function reset()
{
$this-&gt;buffering = true;
}
}
}
namespace Monolog\Handler
{
use Monolog\Logger;
class TestHandler extends AbstractProcessingHandler
{
protected $records = array();
protected $recordsByLevel = array();
public function getRecords()
{
return $this-&gt;records;
}
public function hasEmergency($record)
{
return $this-&gt;hasRecord($record, Logger::EMERGENCY);
}
public function hasAlert($record)
{
return $this-&gt;hasRecord($record, Logger::ALERT);
}
public function hasCritical($record)
{
return $this-&gt;hasRecord($record, Logger::CRITICAL);
}
public function hasError($record)
{
return $this-&gt;hasRecord($record, Logger::ERROR);
}
public function hasWarning($record)
{
return $this-&gt;hasRecord($record, Logger::WARNING);
}
public function hasNotice($record)
{
return $this-&gt;hasRecord($record, Logger::NOTICE);
}
public function hasInfo($record)
{
return $this-&gt;hasRecord($record, Logger::INFO);
}
public function hasDebug($record)
{
return $this-&gt;hasRecord($record, Logger::DEBUG);
}
public function hasEmergencyRecords()
{
return isset($this-&gt;recordsByLevel[Logger::EMERGENCY]);
}
public function hasAlertRecords()
{
return isset($this-&gt;recordsByLevel[Logger::ALERT]);
}
public function hasCriticalRecords()
{
return isset($this-&gt;recordsByLevel[Logger::CRITICAL]);
}
public function hasErrorRecords()
{
return isset($this-&gt;recordsByLevel[Logger::ERROR]);
}
public function hasWarningRecords()
{
return isset($this-&gt;recordsByLevel[Logger::WARNING]);
}
public function hasNoticeRecords()
{
return isset($this-&gt;recordsByLevel[Logger::NOTICE]);
}
public function hasInfoRecords()
{
return isset($this-&gt;recordsByLevel[Logger::INFO]);
}
public function hasDebugRecords()
{
return isset($this-&gt;recordsByLevel[Logger::DEBUG]);
}
protected function hasRecord($record, $level)
{
if (!isset($this-&gt;recordsByLevel[$level])) {
return false;
}
if (is_array($record)) {
$record = $record[&#039;message&#039;];
}
foreach ($this-&gt;recordsByLevel[$level] as $rec) {
if ($rec[&#039;message&#039;] === $record) {
return true;
}
}
return false;
}
protected function write(array $record)
{
$this-&gt;recordsByLevel[$record[&#039;level&#039;]][] = $record;
$this-&gt;records[] = $record;
}
}
}
namespace Psr\Log
{
interface LoggerInterface
{
public function emergency($message, array $context = array());
public function alert($message, array $context = array());
public function critical($message, array $context = array());
public function error($message, array $context = array());
public function warning($message, array $context = array());
public function notice($message, array $context = array());
public function info($message, array $context = array());
public function debug($message, array $context = array());
public function log($level, $message, array $context = array());
}
}
namespace Monolog
{
use Monolog\Handler\HandlerInterface;
use Monolog\Handler\StreamHandler;
use Psr\Log\LoggerInterface;
use Psr\Log\InvalidArgumentException;
class Logger implements LoggerInterface
{
const DEBUG = 100;
const INFO = 200;
const NOTICE = 250;
const WARNING = 300;
const ERROR = 400;
const CRITICAL = 500;
const ALERT = 550;
const EMERGENCY = 600;
const API = 1;
protected static $levels = array(
100 =&gt;&#039;DEBUG&#039;,
200 =&gt;&#039;INFO&#039;,
250 =&gt;&#039;NOTICE&#039;,
300 =&gt;&#039;WARNING&#039;,
400 =&gt;&#039;ERROR&#039;,
500 =&gt;&#039;CRITICAL&#039;,
550 =&gt;&#039;ALERT&#039;,
600 =&gt;&#039;EMERGENCY&#039;,
);
protected static $timezone;
protected $name;
protected $handlers;
protected $processors;
public function __construct($name, array $handlers = array(), array $processors = array())
{
$this-&gt;name = $name;
$this-&gt;handlers = $handlers;
$this-&gt;processors = $processors;
}
public function getName()
{
return $this-&gt;name;
}
public function pushHandler(HandlerInterface $handler)
{
array_unshift($this-&gt;handlers, $handler);
}
public function popHandler()
{
if (!$this-&gt;handlers) {
throw new \LogicException(&#039;You tried to pop from an empty handler stack.&#039;);
}
return array_shift($this-&gt;handlers);
}
public function pushProcessor($callback)
{
if (!is_callable($callback)) {
throw new \InvalidArgumentException(&#039;Processors must be valid callables (callback or object with an __invoke method), &#039;.var_export($callback, true).&#039; given&#039;);
}
array_unshift($this-&gt;processors, $callback);
}
public function popProcessor()
{
if (!$this-&gt;processors) {
throw new \LogicException(&#039;You tried to pop from an empty processor stack.&#039;);
}
return array_shift($this-&gt;processors);
}
public function addRecord($level, $message, array $context = array())
{
if (!$this-&gt;handlers) {
$this-&gt;pushHandler(new StreamHandler(&#039;php://stderr&#039;, static::DEBUG));
}
if (!static::$timezone) {
static::$timezone = new \DateTimeZone(date_default_timezone_get() ?:&#039;UTC&#039;);
}
$record = array(&#039;message&#039;=&gt; (string) $message,&#039;context&#039;=&gt; $context,&#039;level&#039;=&gt; $level,&#039;level_name&#039;=&gt; static::getLevelName($level),&#039;channel&#039;=&gt; $this-&gt;name,&#039;datetime&#039;=&gt; \DateTime::createFromFormat(&#039;U.u&#039;, sprintf(&#039;%.6F&#039;, microtime(true)), static::$timezone)-&gt;setTimezone(static::$timezone),&#039;extra&#039;=&gt; array(),
);
$handlerKey = null;
foreach ($this-&gt;handlers as $key =&gt; $handler) {
if ($handler-&gt;isHandling($record)) {
$handlerKey = $key;
break;
}
}
if (null === $handlerKey) {
return false;
}
foreach ($this-&gt;processors as $processor) {
$record = call_user_func($processor, $record);
}
while (isset($this-&gt;handlers[$handlerKey]) &amp;&amp;
false === $this-&gt;handlers[$handlerKey]-&gt;handle($record)) {
$handlerKey++;
}
return true;
}
public function addDebug($message, array $context = array())
{
return $this-&gt;addRecord(static::DEBUG, $message, $context);
}
public function addInfo($message, array $context = array())
{
return $this-&gt;addRecord(static::INFO, $message, $context);
}
public function addNotice($message, array $context = array())
{
return $this-&gt;addRecord(static::NOTICE, $message, $context);
}
public function addWarning($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function addError($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function addCritical($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function addAlert($message, array $context = array())
{
return $this-&gt;addRecord(static::ALERT, $message, $context);
}
public function addEmergency($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public static function getLevels()
{
return array_flip(static::$levels);
}
public static function getLevelName($level)
{
if (!isset(static::$levels[$level])) {
throw new InvalidArgumentException(&#039;Level &quot;&#039;.$level.&#039;&quot; is not defined, use one of: &#039;.implode(&#039;, &#039;, array_keys(static::$levels)));
}
return static::$levels[$level];
}
public function isHandling($level)
{
$record = array(&#039;level&#039;=&gt; $level,
);
foreach ($this-&gt;handlers as $handler) {
if ($handler-&gt;isHandling($record)) {
return true;
}
}
return false;
}
public function log($level, $message, array $context = array())
{
if (is_string($level) &amp;&amp; defined(__CLASS__.&#039;::&#039;.strtoupper($level))) {
$level = constant(__CLASS__.&#039;::&#039;.strtoupper($level));
}
return $this-&gt;addRecord($level, $message, $context);
}
public function debug($message, array $context = array())
{
return $this-&gt;addRecord(static::DEBUG, $message, $context);
}
public function info($message, array $context = array())
{
return $this-&gt;addRecord(static::INFO, $message, $context);
}
public function notice($message, array $context = array())
{
return $this-&gt;addRecord(static::NOTICE, $message, $context);
}
public function warn($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function warning($message, array $context = array())
{
return $this-&gt;addRecord(static::WARNING, $message, $context);
}
public function err($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function error($message, array $context = array())
{
return $this-&gt;addRecord(static::ERROR, $message, $context);
}
public function crit($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function critical($message, array $context = array())
{
return $this-&gt;addRecord(static::CRITICAL, $message, $context);
}
public function alert($message, array $context = array())
{
return $this-&gt;addRecord(static::ALERT, $message, $context);
}
public function emerg($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
public function emergency($message, array $context = array())
{
return $this-&gt;addRecord(static::EMERGENCY, $message, $context);
}
}
}
namespace Symfony\Component\HttpKernel\Log
{
use Psr\Log\LoggerInterface as PsrLogger;
interface LoggerInterface extends PsrLogger
{
public function emerg($message, array $context = array());
public function crit($message, array $context = array());
public function err($message, array $context = array());
public function warn($message, array $context = array());
}
}
namespace Symfony\Component\HttpKernel\Log
{
interface DebugLoggerInterface
{
public function getLogs();
public function countErrors();
}
}
namespace Symfony\Bridge\Monolog
{
use Monolog\Logger as BaseLogger;
use Symfony\Component\HttpKernel\Log\LoggerInterface;
use Symfony\Component\HttpKernel\Log\DebugLoggerInterface;
class Logger extends BaseLogger implements LoggerInterface, DebugLoggerInterface
{
public function emerg($message, array $context = array())
{
return parent::addRecord(BaseLogger::EMERGENCY, $message, $context);
}
public function crit($message, array $context = array())
{
return parent::addRecord(BaseLogger::CRITICAL, $message, $context);
}
public function err($message, array $context = array())
{
return parent::addRecord(BaseLogger::ERROR, $message, $context);
}
public function warn($message, array $context = array())
{
return parent::addRecord(BaseLogger::WARNING, $message, $context);
}
public function getLogs()
{
if ($logger = $this-&gt;getDebugLogger()) {
return $logger-&gt;getLogs();
}
return array();
}
public function countErrors()
{
if ($logger = $this-&gt;getDebugLogger()) {
return $logger-&gt;countErrors();
}
return 0;
}
private function getDebugLogger()
{
foreach ($this-&gt;handlers as $handler) {
if ($handler instanceof DebugLoggerInterface) {
return $handler;
}
}
}
}
}
namespace Symfony\Bridge\Monolog\Handler
{
use Monolog\Logger;
use Monolog\Handler\TestHandler;
use Symfony\Component\HttpKernel\Log\DebugLoggerInterface;
class DebugHandler extends TestHandler implements DebugLoggerInterface
{
public function getLogs()
{
$records = array();
foreach ($this-&gt;records as $record) {
$records[] = array(&#039;timestamp&#039;=&gt; $record[&#039;datetime&#039;]-&gt;getTimestamp(),&#039;message&#039;=&gt; $record[&#039;message&#039;],&#039;priority&#039;=&gt; $record[&#039;level&#039;],&#039;priorityName&#039;=&gt; $record[&#039;level_name&#039;],&#039;context&#039;=&gt; $record[&#039;context&#039;],
);
}
return $records;
}
public function countErrors()
{
$cnt = 0;
$levels = array(Logger::ERROR, Logger::CRITICAL, Logger::ALERT, Logger::EMERGENCY);
foreach ($levels as $level) {
if (isset($this-&gt;recordsByLevel[$level])) {
$cnt += count($this-&gt;recordsByLevel[$level]);
}
}
return $cnt;
}
}
}
namespace Monolog\Handler\FingersCrossed
{
interface ActivationStrategyInterface
{
public function isHandlerActivated(array $record);
}
}
namespace Monolog\Handler\FingersCrossed
{
class ErrorLevelActivationStrategy implements ActivationStrategyInterface
{
private $actionLevel;
public function __construct($actionLevel)
{
$this-&gt;actionLevel = $actionLevel;
}
public function isHandlerActivated(array $record)
{
return $record[&#039;level&#039;] &gt;= $this-&gt;actionLevel;
}
}
}
namespace Assetic
{
interface ValueSupplierInterface
{
public function getValues();
}
}
namespace Symfony\Bundle\AsseticBundle
{
use Assetic\ValueSupplierInterface;
use Symfony\Component\DependencyInjection\ContainerInterface;
class DefaultValueSupplier implements ValueSupplierInterface
{
protected $container;
public function __construct(ContainerInterface $container)
{
$this-&gt;container = $container;
}
public function getValues()
{
if (!$this-&gt;container-&gt;isScopeActive(&#039;request&#039;)) {
return array();
}
$request = $this-&gt;container-&gt;get(&#039;request&#039;);
return array(&#039;locale&#039;=&gt; $request-&gt;getLocale(),&#039;env&#039;=&gt; $this-&gt;container-&gt;getParameter(&#039;kernel.environment&#039;),
);
}
}
}
namespace Assetic\Factory
{
use Assetic\Asset\AssetCollection;
use Assetic\Asset\AssetCollectionInterface;
use Assetic\Asset\AssetInterface;
use Assetic\Asset\AssetReference;
use Assetic\Asset\FileAsset;
use Assetic\Asset\GlobAsset;
use Assetic\Asset\HttpAsset;
use Assetic\AssetManager;
use Assetic\Factory\Worker\WorkerInterface;
use Assetic\FilterManager;
class AssetFactory
{
private $root;
private $debug;
private $output;
private $workers;
private $am;
private $fm;
public function __construct($root, $debug = false)
{
$this-&gt;root = rtrim($root,&#039;/&#039;);
$this-&gt;debug = $debug;
$this-&gt;output =&#039;assetic/*&#039;;
$this-&gt;workers = array();
}
public function setDebug($debug)
{
$this-&gt;debug = $debug;
}
public function isDebug()
{
return $this-&gt;debug;
}
public function setDefaultOutput($output)
{
$this-&gt;output = $output;
}
public function addWorker(WorkerInterface $worker)
{
$this-&gt;workers[] = $worker;
}
public function getAssetManager()
{
return $this-&gt;am;
}
public function setAssetManager(AssetManager $am)
{
$this-&gt;am = $am;
}
public function getFilterManager()
{
return $this-&gt;fm;
}
public function setFilterManager(FilterManager $fm)
{
$this-&gt;fm = $fm;
}
public function createAsset($inputs = array(), $filters = array(), array $options = array())
{
if (!is_array($inputs)) {
$inputs = array($inputs);
}
if (!is_array($filters)) {
$filters = array($filters);
}
if (!isset($options[&#039;output&#039;])) {
$options[&#039;output&#039;] = $this-&gt;output;
}
if (!isset($options[&#039;vars&#039;])) {
$options[&#039;vars&#039;] = array();
}
if (!isset($options[&#039;debug&#039;])) {
$options[&#039;debug&#039;] = $this-&gt;debug;
}
if (!isset($options[&#039;root&#039;])) {
$options[&#039;root&#039;] = array($this-&gt;root);
} else {
if (!is_array($options[&#039;root&#039;])) {
$options[&#039;root&#039;] = array($options[&#039;root&#039;]);
}
$options[&#039;root&#039;][] = $this-&gt;root;
}
if (!isset($options[&#039;name&#039;])) {
$options[&#039;name&#039;] = $this-&gt;generateAssetName($inputs, $filters, $options);
}
$asset = $this-&gt;createAssetCollection(array(), $options);
$extensions = array();
foreach ($inputs as $input) {
if (is_array($input)) {
$asset-&gt;add(call_user_func_array(array($this,&#039;createAsset&#039;), $input));
} else {
$asset-&gt;add($this-&gt;parseInput($input, $options));
$extensions[pathinfo($input, PATHINFO_EXTENSION)] = true;
}
}
foreach ($filters as $filter) {
if (&#039;?&#039;!= $filter[0]) {
$asset-&gt;ensureFilter($this-&gt;getFilter($filter));
} elseif (!$options[&#039;debug&#039;]) {
$asset-&gt;ensureFilter($this-&gt;getFilter(substr($filter, 1)));
}
}
if (!empty($options[&#039;vars&#039;])) {
$toAdd = array();
foreach ($options[&#039;vars&#039;] as $var) {
if (false !== strpos($options[&#039;output&#039;],&#039;{&#039;.$var.&#039;}&#039;)) {
continue;
}
$toAdd[] =&#039;{&#039;.$var.&#039;}&#039;;
}
if ($toAdd) {
$options[&#039;output&#039;] = str_replace(&#039;*&#039;,&#039;*.&#039;.implode(&#039;.&#039;, $toAdd), $options[&#039;output&#039;]);
}
}
if (1 == count($extensions) &amp;&amp; !pathinfo($options[&#039;output&#039;], PATHINFO_EXTENSION) &amp;&amp; $extension = key($extensions)) {
$options[&#039;output&#039;] .=&#039;.&#039;.$extension;
}
$asset-&gt;setTargetPath(str_replace(&#039;*&#039;, $options[&#039;name&#039;], $options[&#039;output&#039;]));
return $this-&gt;applyWorkers($asset);
}
public function generateAssetName($inputs, $filters, $options = array())
{
foreach (array_diff(array_keys($options), array(&#039;output&#039;,&#039;debug&#039;,&#039;root&#039;)) as $key) {
unset($options[$key]);
}
ksort($options);
return substr(sha1(serialize($inputs).serialize($filters).serialize($options)), 0, 7);
}
protected function parseInput($input, array $options = array())
{
if (&#039;@&#039;== $input[0]) {
return $this-&gt;createAssetReference(substr($input, 1));
}
if (false !== strpos($input,&#039;://&#039;) || 0 === strpos($input,&#039;//&#039;)) {
return $this-&gt;createHttpAsset($input, $options[&#039;vars&#039;]);
}
if (self::isAbsolutePath($input)) {
if ($root = self::findRootDir($input, $options[&#039;root&#039;])) {
$path = ltrim(substr($input, strlen($root)),&#039;/&#039;);
} else {
$path = null;
}
} else {
$root = $this-&gt;root;
$path = $input;
$input = $this-&gt;root.&#039;/&#039;.$path;
}
if (false !== strpos($input,&#039;*&#039;)) {
return $this-&gt;createGlobAsset($input, $root, $options[&#039;vars&#039;]);
}
return $this-&gt;createFileAsset($input, $root, $path, $options[&#039;vars&#039;]);
}
protected function createAssetCollection(array $assets = array(), array $options = array())
{
return new AssetCollection($assets, array(), null, isset($options[&#039;vars&#039;]) ? $options[&#039;vars&#039;] : array());
}
protected function createAssetReference($name)
{
if (!$this-&gt;am) {
throw new \LogicException(&#039;There is no asset manager.&#039;);
}
return new AssetReference($this-&gt;am, $name);
}
protected function createHttpAsset($sourceUrl, $vars)
{
return new HttpAsset($sourceUrl, array(), false, $vars);
}
protected function createGlobAsset($glob, $root = null, $vars)
{
return new GlobAsset($glob, array(), $root, $vars);
}
protected function createFileAsset($source, $root = null, $path = null, $vars)
{
return new FileAsset($source, array(), $root, $path, $vars);
}
protected function getFilter($name)
{
if (!$this-&gt;fm) {
throw new \LogicException(&#039;There is no filter manager.&#039;);
}
return $this-&gt;fm-&gt;get($name);
}
private function applyWorkers(AssetCollectionInterface $asset)
{
foreach ($asset as $leaf) {
foreach ($this-&gt;workers as $worker) {
$retval = $worker-&gt;process($leaf);
if ($retval instanceof AssetInterface &amp;&amp; $leaf !== $retval) {
$asset-&gt;replaceLeaf($leaf, $retval);
}
}
}
foreach ($this-&gt;workers as $worker) {
$retval = $worker-&gt;process($asset);
if ($retval instanceof AssetInterface) {
$asset = $retval;
}
}
return $asset instanceof AssetCollectionInterface ? $asset : $this-&gt;createAssetCollection(array($asset));
}
private static function isAbsolutePath($path)
{
return&#039;/&#039;== $path[0] ||&#039;\\&#039;== $path[0] || (3 &lt; strlen($path) &amp;&amp; ctype_alpha($path[0]) &amp;&amp; $path[1] ==&#039;:&#039;&amp;&amp; (&#039;\\&#039;== $path[2] ||&#039;/&#039;== $path[2]));
}
private static function findRootDir($path, array $roots)
{
foreach ($roots as $root) {
if (0 === strpos($path, $root)) {
return $root;
}
}
}
}
}
namespace Symfony\Bundle\AsseticBundle\Factory
{
use Assetic\Factory\AssetFactory as BaseAssetFactory;
use Symfony\Component\DependencyInjection\ContainerInterface;
use Symfony\Component\DependencyInjection\ParameterBag\ParameterBagInterface;
use Symfony\Component\HttpKernel\KernelInterface;
class AssetFactory extends BaseAssetFactory
{
private $kernel;
private $container;
private $parameterBag;
public function __construct(KernelInterface $kernel, ContainerInterface $container, ParameterBagInterface $parameterBag, $baseDir, $debug = false)
{
$this-&gt;kernel = $kernel;
$this-&gt;container = $container;
$this-&gt;parameterBag = $parameterBag;
parent::__construct($baseDir, $debug);
}
protected function parseInput($input, array $options = array())
{
$input = $this-&gt;parameterBag-&gt;resolveValue($input);
if (&#039;@&#039;== $input[0] &amp;&amp; false !== strpos($input,&#039;/&#039;)) {
$bundle = substr($input, 1);
if (false !== $pos = strpos($bundle,&#039;/&#039;)) {
$bundle = substr($bundle, 0, $pos);
}
$options[&#039;root&#039;] = array($this-&gt;kernel-&gt;getBundle($bundle)-&gt;getPath());
if (false !== $pos = strpos($input,&#039;*&#039;)) {
list($before, $after) = explode(&#039;*&#039;, $input, 2);
$input = $this-&gt;kernel-&gt;locateResource($before).&#039;*&#039;.$after;
} else {
$input = $this-&gt;kernel-&gt;locateResource($input);
}
}
return parent::parseInput($input, $options);
}
protected function createAssetReference($name)
{
if (!$this-&gt;getAssetManager()) {
$this-&gt;setAssetManager($this-&gt;container-&gt;get(&#039;assetic.asset_manager&#039;));
}
return parent::createAssetReference($name);
}
protected function getFilter($name)
{
if (!$this-&gt;getFilterManager()) {
$this-&gt;setFilterManager($this-&gt;container-&gt;get(&#039;assetic.filter_manager&#039;));
}
return parent::getFilter($name);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Doctrine\Common\Annotations\Reader;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
use Doctrine\Common\Util\ClassUtils;
class ControllerListener implements EventSubscriberInterface
{
protected $reader;
public function __construct(Reader $reader)
{
$this-&gt;reader = $reader;
}
public function onKernelController(FilterControllerEvent $event)
{
if (!is_array($controller = $event-&gt;getController())) {
return;
}
$className = class_exists(&#039;Doctrine\Common\Util\ClassUtils&#039;) ? ClassUtils::getClass($controller[0]) : get_class($controller[0]);
$object = new \ReflectionClass($className);
$method = $object-&gt;getMethod($controller[1]);
$classConfigurations = $this-&gt;getConfigurations($this-&gt;reader-&gt;getClassAnnotations($object));
$methodConfigurations = $this-&gt;getConfigurations($this-&gt;reader-&gt;getMethodAnnotations($method));
$configurations = array();
foreach (array_merge(array_keys($classConfigurations), array_keys($methodConfigurations)) as $key) {
if (!array_key_exists($key, $classConfigurations)) {
$configurations[$key] = $methodConfigurations[$key];
} elseif (!array_key_exists($key, $methodConfigurations)) {
$configurations[$key] = $classConfigurations[$key];
} else {
if (is_array($classConfigurations[$key])) {
if (!is_array($methodConfigurations[$key])) {
throw new \UnexpectedValueException(&#039;Configurations should both be an array or both not be an array&#039;);
}
$configurations[$key] = array_merge($classConfigurations[$key], $methodConfigurations[$key]);
} else {
$configurations[$key] = $methodConfigurations[$key];
}
}
}
$request = $event-&gt;getRequest();
foreach ($configurations as $key =&gt; $attributes) {
$request-&gt;attributes-&gt;set($key, $attributes);
}
}
protected function getConfigurations(array $annotations)
{
$configurations = array();
foreach ($annotations as $configuration) {
if ($configuration instanceof ConfigurationInterface) {
if ($configuration-&gt;allowArray()) {
$configurations[&#039;_&#039;.$configuration-&gt;getAliasName()][] = $configuration;
} else {
$configurations[&#039;_&#039;.$configuration-&gt;getAliasName()] = $configuration;
}
}
}
return $configurations;
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;,
);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterManager;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
class ParamConverterListener implements EventSubscriberInterface
{
protected $manager;
public function __construct(ParamConverterManager $manager)
{
$this-&gt;manager = $manager;
}
public function onKernelController(FilterControllerEvent $event)
{
$controller = $event-&gt;getController();
$request = $event-&gt;getRequest();
$configurations = array();
if ($configuration = $request-&gt;attributes-&gt;get(&#039;_converters&#039;)) {
foreach (is_array($configuration) ? $configuration : array($configuration) as $configuration) {
$configurations[$configuration-&gt;getName()] = $configuration;
}
}
if (is_array($controller)) {
$r = new \ReflectionMethod($controller[0], $controller[1]);
} else {
$r = new \ReflectionFunction($controller);
}
foreach ($r-&gt;getParameters() as $param) {
if (!$param-&gt;getClass() || $param-&gt;getClass()-&gt;isInstance($request)) {
continue;
}
$name = $param-&gt;getName();
if (!isset($configurations[$name])) {
$configuration = new ParamConverter(array());
$configuration-&gt;setName($name);
$configuration-&gt;setClass($param-&gt;getClass()-&gt;getName());
$configurations[$name] = $configuration;
} elseif (null === $configurations[$name]-&gt;getClass()) {
$configurations[$name]-&gt;setClass($param-&gt;getClass()-&gt;getName());
}
$configurations[$name]-&gt;setIsOptional($param-&gt;isOptional());
}
$this-&gt;manager-&gt;apply($request, $configurations);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;,
);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpFoundation\Request;
interface ParamConverterInterface
{
public function apply(Request $request, ParamConverter $configuration);
public function supports(ParamConverter $configuration);
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use DateTime;
class DateTimeParamConverter implements ParamConverterInterface
{
public function apply(Request $request, ParamConverter $configuration)
{
$param = $configuration-&gt;getName();
if (!$request-&gt;attributes-&gt;has($param)) {
return false;
}
$options = $configuration-&gt;getOptions();
$value = $request-&gt;attributes-&gt;get($param);
if (!$value &amp;&amp; $configuration-&gt;isOptional()) {
return false;
}
$date = isset($options[&#039;format&#039;])
? DateTime::createFromFormat($options[&#039;format&#039;], $value)
: new DateTime($value);
if (!$date) {
throw new NotFoundHttpException(&#039;Invalid date given.&#039;);
}
$request-&gt;attributes-&gt;set($param, $date);
return true;
}
public function supports(ParamConverter $configuration)
{
if (null === $configuration-&gt;getClass()) {
return false;
}
return&quot;DateTime&quot;=== $configuration-&gt;getClass();
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ParamConverter;
use Symfony\Component\HttpKernel\Exception\NotFoundHttpException;
use Symfony\Component\HttpFoundation\Request;
use Doctrine\Common\Persistence\ManagerRegistry;
use Doctrine\ORM\NoResultException;
class DoctrineParamConverter implements ParamConverterInterface
{
protected $registry;
public function __construct(ManagerRegistry $registry = null)
{
$this-&gt;registry = $registry;
}
public function apply(Request $request, ParamConverter $configuration)
{
$name = $configuration-&gt;getName();
$class = $configuration-&gt;getClass();
$options = $this-&gt;getOptions($configuration);
if (null === $request-&gt;attributes-&gt;get($name, false)) {
$configuration-&gt;setIsOptional(true);
}
if (false === $object = $this-&gt;find($class, $request, $options, $name)) {
if (false === $object = $this-&gt;findOneBy($class, $request, $options)) {
if ($configuration-&gt;isOptional()) {
$object = null;
} else {
throw new \LogicException(&#039;Unable to guess how to get a Doctrine instance from the request information.&#039;);
}
}
}
if (null === $object &amp;&amp; false === $configuration-&gt;isOptional()) {
throw new NotFoundHttpException(sprintf(&#039;%s object not found.&#039;, $class));
}
$request-&gt;attributes-&gt;set($name, $object);
return true;
}
protected function find($class, Request $request, $options, $name)
{
if ($options[&#039;mapping&#039;] || $options[&#039;exclude&#039;]) {
return false;
}
$id = $this-&gt;getIdentifier($request, $options, $name);
if (false === $id || null === $id) {
return false;
}
if (isset($options[&#039;repository_method&#039;])) {
$method = $options[&#039;repository_method&#039;];
} else {
$method =&#039;find&#039;;
}
try {
return $this-&gt;getManager($options[&#039;entity_manager&#039;], $class)-&gt;getRepository($class)-&gt;$method($id);
} catch (NoResultException $e) {
return null;
}
}
protected function getIdentifier(Request $request, $options, $name)
{
if (isset($options[&#039;id&#039;])) {
if (!is_array($options[&#039;id&#039;])) {
$name = $options[&#039;id&#039;];
} elseif (is_array($options[&#039;id&#039;])) {
$id = array();
foreach ($options[&#039;id&#039;] as $field) {
$id[$field] = $request-&gt;attributes-&gt;get($field);
}
return $id;
}
}
if ($request-&gt;attributes-&gt;has($name)) {
return $request-&gt;attributes-&gt;get($name);
}
if ($request-&gt;attributes-&gt;has(&#039;id&#039;)) {
return $request-&gt;attributes-&gt;get(&#039;id&#039;);
}
return false;
}
protected function findOneBy($class, Request $request, $options)
{
if (!$options[&#039;mapping&#039;]) {
$keys = $request-&gt;attributes-&gt;keys();
$options[&#039;mapping&#039;] = $keys ? array_combine($keys, $keys) : array();
}
foreach ($options[&#039;exclude&#039;] as $exclude) {
unset($options[&#039;mapping&#039;][$exclude]);
}
if (!$options[&#039;mapping&#039;]) {
return false;
}
$criteria = array();
$em = $this-&gt;getManager($options[&#039;entity_manager&#039;], $class);
$metadata = $em-&gt;getClassMetadata($class);
foreach ($options[&#039;mapping&#039;] as $attribute =&gt; $field) {
if ($metadata-&gt;hasField($field) || ($metadata-&gt;hasAssociation($field) &amp;&amp; $metadata-&gt;isSingleValuedAssociation($field))) {
$criteria[$field] = $request-&gt;attributes-&gt;get($attribute);
}
}
if ($options[&#039;strip_null&#039;]) {
$criteria = array_filter($criteria, function ($value) { return !is_null($value); });
}
if (!$criteria) {
return false;
}
if (isset($options[&#039;repository_method&#039;])) {
$method = $options[&#039;repository_method&#039;];
} else {
$method =&#039;findOneBy&#039;;
}
try {
return $em-&gt;getRepository($class)-&gt;$method($criteria);
} catch (NoResultException $e) {
return null;
}
}
public function supports(ParamConverter $configuration)
{
if (null === $this-&gt;registry || !count($this-&gt;registry-&gt;getManagers())) {
return false;
}
if (null === $configuration-&gt;getClass()) {
return false;
}
$options = $this-&gt;getOptions($configuration);
$em = $this-&gt;getManager($options[&#039;entity_manager&#039;], $configuration-&gt;getClass());
if (null === $em) {
return false;
}
return ! $em-&gt;getMetadataFactory()-&gt;isTransient($configuration-&gt;getClass());
}
protected function getOptions(ParamConverter $configuration)
{
return array_replace(array(&#039;entity_manager&#039;=&gt; null,&#039;exclude&#039;=&gt; array(),&#039;mapping&#039;=&gt; array(),&#039;strip_null&#039;=&gt; false,
), $configuration-&gt;getOptions());
}
private function getManager($name, $class)
{
if (null === $name) {
return $this-&gt;registry-&gt;getManagerForClass($class);
}
return $this-&gt;registry-&gt;getManager($name);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter
{
use Symfony\Component\HttpFoundation\Request;
use Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationInterface;
class ParamConverterManager
{
protected $converters = array();
protected $namedConverters = array();
public function apply(Request $request, $configurations)
{
if (is_object($configurations)) {
$configurations = array($configurations);
}
foreach ($configurations as $configuration) {
$this-&gt;applyConverter($request, $configuration);
}
}
protected function applyConverter(Request $request, ConfigurationInterface $configuration)
{
$value = $request-&gt;attributes-&gt;get($configuration-&gt;getName());
$className = $configuration-&gt;getClass();
if (is_object($value) &amp;&amp; $value instanceof $className) {
return;
}
if ($converterName = $configuration-&gt;getConverter()) {
if (!isset($this-&gt;namedConverters[$converterName])) {
throw new \RuntimeException(sprintf(&quot;No converter named &#039;%s&#039; found for conversion of parameter &#039;%s&#039;.&quot;,
$converterName, $configuration-&gt;getName()
));
}
$converter = $this-&gt;namedConverters[$converterName];
if (!$converter-&gt;supports($configuration)) {
throw new \RuntimeException(sprintf(&quot;Converter &#039;%s&#039; does not support conversion of parameter &#039;%s&#039;.&quot;,
$converterName, $configuration-&gt;getName()
));
}
$converter-&gt;apply($request, $configuration);
return;
}
foreach ($this-&gt;all() as $converter) {
if ($converter-&gt;supports($configuration)) {
if ($converter-&gt;apply($request, $configuration)) {
return;
}
}
}
}
public function add(ParamConverterInterface $converter, $priority = 0, $name = null)
{
if ($priority !== null) {
if (!isset($this-&gt;converters[$priority])) {
$this-&gt;converters[$priority] = array();
}
$this-&gt;converters[$priority][] = $converter;
}
if (null !== $name) {
$this-&gt;namedConverters[$name] = $converter;
}
}
public function all()
{
krsort($this-&gt;converters);
$converters = array();
foreach ($this-&gt;converters as $all) {
$converters = array_merge($converters, $all);
}
return $converters;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\Event\FilterResponseEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpFoundation\Response;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\ExpressionLanguage\ExpressionLanguage;
class HttpCacheListener implements EventSubscriberInterface
{
private $lastModifiedDates;
private $etags;
private $expressionLanguage;
public function __construct()
{
$this-&gt;lastModifiedDates = new \SplObjectStorage();
$this-&gt;etags = new \SplObjectStorage();
}
public function onKernelController(FilterControllerEvent $event)
{
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_cache&#039;)) {
return;
}
$response = new Response();
$lastModifiedDate =&#039;&#039;;
if ($configuration-&gt;getLastModified()) {
$lastModifiedDate = $this-&gt;getExpressionLanguage()-&gt;evaluate($configuration-&gt;getLastModified(), $request-&gt;attributes-&gt;all());
$response-&gt;setLastModified($lastModifiedDate);
}
$etag =&#039;&#039;;
if ($configuration-&gt;getETag()) {
$etag = hash(&#039;sha256&#039;, $this-&gt;getExpressionLanguage()-&gt;evaluate($configuration-&gt;getETag(), $request-&gt;attributes-&gt;all()));
$response-&gt;setETag($etag);
}
if ($response-&gt;isNotModified($request)) {
$event-&gt;setController(function () use ($response) {
return $response;
});
} else {
if ($etag) {
$this-&gt;etags[$request] = $etag;
}
if ($lastModifiedDate) {
$this-&gt;lastModifiedDates[$request] = $lastModifiedDate;
}
}
}
public function onKernelResponse(FilterResponseEvent $event)
{
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_cache&#039;)) {
return;
}
$response = $event-&gt;getResponse();
if (!$response-&gt;isSuccessful()) {
return;
}
if (null !== $configuration-&gt;getSMaxAge()) {
$response-&gt;setSharedMaxAge($configuration-&gt;getSMaxAge());
}
if (null !== $configuration-&gt;getMaxAge()) {
$response-&gt;setMaxAge($configuration-&gt;getMaxAge());
}
if (null !== $configuration-&gt;getExpires()) {
$date = \DateTime::createFromFormat(&#039;U&#039;, strtotime($configuration-&gt;getExpires()), new \DateTimeZone(&#039;UTC&#039;));
$response-&gt;setExpires($date);
}
if (null !== $configuration-&gt;getVary()) {
$response-&gt;setVary($configuration-&gt;getVary());
}
if ($configuration-&gt;isPublic()) {
$response-&gt;setPublic();
}
if (isset($this-&gt;lastModifiedDates[$request])) {
$response-&gt;setLastModified($this-&gt;lastModifiedDates[$request]);
unset($this-&gt;lastModifiedDates[$request]);
}
if (isset($this-&gt;etags[$request])) {
$response-&gt;setETag($this-&gt;etags[$request]);
unset($this-&gt;etags[$request]);
}
$event-&gt;setResponse($response);
}
public static function getSubscribedEvents()
{
return array(
KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;,
KernelEvents::RESPONSE =&gt;&#039;onKernelResponse&#039;,
);
}
private function getExpressionLanguage()
{
if (null === $this-&gt;expressionLanguage) {
if (!class_exists(&#039;Symfony\Component\ExpressionLanguage\ExpressionLanguage&#039;)) {
throw new \RuntimeException(&#039;Unable to use expressions as the Symfony ExpressionLanguage component is not installed.&#039;);
}
$this-&gt;expressionLanguage = new ExpressionLanguage();
}
return $this-&gt;expressionLanguage;
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\EventListener
{
use Sensio\Bundle\FrameworkExtraBundle\Security\ExpressionLanguage;
use Symfony\Component\HttpKernel\Event\FilterControllerEvent;
use Symfony\Component\HttpKernel\KernelEvents;
use Symfony\Component\HttpFoundation\Request;
use Symfony\Component\EventDispatcher\EventSubscriberInterface;
use Symfony\Component\ExpressionLanguage\Expression;
use Symfony\Component\Security\Core\Authentication\AuthenticationTrustResolverInterface;
use Symfony\Component\Security\Core\SecurityContextInterface;
use Symfony\Component\Security\Core\Exception\AccessDeniedException;
use Symfony\Component\Security\Core\Role\RoleHierarchyInterface;
class SecurityListener implements EventSubscriberInterface
{
private $securityContext;
private $language;
private $trustResolver;
private $roleHierarchy;
public function __construct(SecurityContextInterface $securityContext = null, ExpressionLanguage $language = null, AuthenticationTrustResolverInterface $trustResolver = null, RoleHierarchyInterface $roleHierarchy = null)
{
$this-&gt;securityContext = $securityContext;
$this-&gt;language = $language;
$this-&gt;trustResolver = $trustResolver;
$this-&gt;roleHierarchy = $roleHierarchy;
}
public function onKernelController(FilterControllerEvent $event)
{
$request = $event-&gt;getRequest();
if (!$configuration = $request-&gt;attributes-&gt;get(&#039;_security&#039;)) {
return;
}
if (null === $this-&gt;securityContext || null === $this-&gt;trustResolver) {
throw new \LogicException(&#039;To use the @Security tag, you need to install the Symfony Security bundle.&#039;);
}
if (!$this-&gt;language-&gt;evaluate($configuration-&gt;getExpression(), $this-&gt;getVariables($request))) {
throw new AccessDeniedException(sprintf(&#039;Expression &quot;%s&quot; denied access.&#039;, $configuration-&gt;getExpression()));
}
}
private function getVariables(Request $request)
{
$token = $this-&gt;securityContext-&gt;getToken();
if (null !== $this-&gt;roleHierarchy) {
$roles = $this-&gt;roleHierarchy-&gt;getReachableRoles($token-&gt;getRoles());
} else {
$roles = $token-&gt;getRoles();
}
$variables = array(&#039;token&#039;=&gt; $token,&#039;user&#039;=&gt; $token-&gt;getUser(),&#039;object&#039;=&gt; $request,&#039;request&#039;=&gt; $request,&#039;roles&#039;=&gt; array_map(function ($role) { return $role-&gt;getRole(); }, $roles),&#039;trust_resolver&#039;=&gt; $this-&gt;trustResolver,&#039;security_context&#039;=&gt; $this-&gt;securityContext,
);
return array_merge($request-&gt;attributes-&gt;all(), $variables);
}
public static function getSubscribedEvents()
{
return array(KernelEvents::CONTROLLER =&gt;&#039;onKernelController&#039;);
}
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Configuration
{
interface ConfigurationInterface
{
public function getAliasName();
public function allowArray();
}
}
namespace Sensio\Bundle\FrameworkExtraBundle\Configuration
{
abstract class ConfigurationAnnotation implements ConfigurationInterface
{
public function __construct(array $values)
{
foreach ($values as $k =&gt; $v) {
if (!method_exists($this, $name =&#039;set&#039;.$k)) {
throw new \RuntimeException(sprintf(&#039;Unknown key &quot;%s&quot; for annotation &quot;@%s&quot;.&#039;, $k, get_class($this)));
}
$this-&gt;$name($v);
}
}
}
}') in /home/darek/Projekty/www/words2/vendor/symfony/symfony/src/Symfony/Component/ClassLoader/ClassCollectionLoader.php line 122</li>
       <li>at <abbr title="Symfony\Component\ClassLoader\ClassCollectionLoader">ClassCollectionLoader</abbr>::load(<em>array</em>('Symfony\Bundle\FrameworkBundle\EventListener\SessionListener', 'Symfony\Component\HttpFoundation\Session\Storage\NativeSessionStorage', 'Symfony\Component\HttpFoundation\Session\Storage\PhpBridgeSessionStorage', 'Symfony\Component\HttpFoundation\Session\Storage\Handler\NativeFileSessionHandler', 'Symfony\Component\HttpFoundation\Session\Storage\Proxy\AbstractProxy', 'Symfony\Component\HttpFoundation\Session\Storage\Proxy\SessionHandlerProxy', 'Symfony\Component\HttpFoundation\Session\Session', 'Symfony\Bundle\FrameworkBundle\Templating\GlobalVariables', 'Symfony\Bundle\FrameworkBundle\Templating\TemplateReference', 'Symfony\Bundle\FrameworkBundle\Templating\TemplateNameParser', 'Symfony\Bundle\FrameworkBundle\Templating\Loader\TemplateLocator', 'Symfony\Component\Routing\Generator\UrlGenerator', 'Symfony\Component\Routing\RequestContext', 'Symfony\Component\Routing\Router', 'Symfony\Bundle\FrameworkBundle\Routing\RedirectableUrlMatcher', 'Symfony\Bundle\FrameworkBundle\Routing\Router', 'Symfony\Component\Config\FileLocator', 'Symfony\Component\EventDispatcher\Event', 'Symfony\Component\EventDispatcher\ContainerAwareEventDispatcher', 'Symfony\Component\HttpKernel\EventListener\ResponseListener', 'Symfony\Component\HttpKernel\EventListener\RouterListener', 'Symfony\Component\HttpKernel\Controller\ControllerResolver', 'Symfony\Component\HttpKernel\Event\KernelEvent', 'Symfony\Component\HttpKernel\Event\FilterControllerEvent', 'Symfony\Component\HttpKernel\Event\FilterResponseEvent', 'Symfony\Component\HttpKernel\Event\GetResponseEvent', 'Symfony\Component\HttpKernel\Event\GetResponseForControllerResultEvent', 'Symfony\Component\HttpKernel\Event\GetResponseForExceptionEvent', 'Symfony\Component\HttpKernel\KernelEvents', 'Symfony\Component\HttpKernel\Config\FileLocator', 'Symfony\Bundle\FrameworkBundle\Controller\ControllerNameParser', 'Symfony\Bundle\FrameworkBundle\Controller\ControllerResolver', 'Symfony\Component\Security\Http\Firewall', 'Symfony\Component\Security\Core\SecurityContext', 'Symfony\Component\Security\Core\User\UserProviderInterface', 'Symfony\Component\Security\Core\Authentication\AuthenticationProviderManager', 'Symfony\Component\Security\Core\Authorization\AccessDecisionManager', 'Symfony\Component\Security\Core\Authorization\Voter\VoterInterface', 'Symfony\Bundle\SecurityBundle\Security\FirewallMap', 'Symfony\Bundle\SecurityBundle\Security\FirewallContext', 'Symfony\Component\HttpFoundation\RequestMatcher', 'Twig_Environment', 'Twig_Extension', 'Twig_Extension_Core', 'Twig_Extension_Escaper', 'Twig_Extension_Optimizer', 'Twig_LoaderInterface', 'Twig_Markup', 'Twig_Template', 'Monolog\Formatter\FormatterInterface', 'Monolog\Formatter\LineFormatter', 'Monolog\Handler\HandlerInterface', 'Monolog\Handler\AbstractHandler', 'Monolog\Handler\AbstractProcessingHandler', 'Monolog\Handler\StreamHandler', 'Monolog\Handler\FingersCrossedHandler', 'Monolog\Handler\TestHandler', 'Monolog\Logger', 'Symfony\Bridge\Monolog\Logger', 'Symfony\Bridge\Monolog\Handler\DebugHandler', 'Monolog\Handler\FingersCrossed\ActivationStrategyInterface', 'Monolog\Handler\FingersCrossed\ErrorLevelActivationStrategy', 'Symfony\Bundle\AsseticBundle\DefaultValueSupplier', 'Symfony\Bundle\AsseticBundle\Factory\AssetFactory', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\ControllerListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\ParamConverterListener', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\DateTimeParamConverter', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\DoctrineParamConverter', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterInterface', 'Sensio\Bundle\FrameworkExtraBundle\Request\ParamConverter\ParamConverterManager', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\HttpCacheListener', 'Sensio\Bundle\FrameworkExtraBundle\EventListener\SecurityListener', 'Sensio\Bundle\FrameworkExtraBundle\Configuration\ConfigurationAnnotation'), '/home/darek/Projekty/www/words2/app/cache/dev', 'classes', <em>true</em>, <em>false</em>, '.php') in /home/darek/Projekty/www/words2/app/bootstrap.php.cache line 2431</li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->doLoadClassCache('classes', '.php') in /home/darek/Projekty/www/words2/app/bootstrap.php.cache line 2267</li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->boot() in /home/darek/Projekty/www/words2/app/bootstrap.php.cache line 2301</li>
       <li>at <abbr title="Symfony\Component\HttpKernel\Kernel">Kernel</abbr>->handle(<em>object</em>(<abbr title="Symfony\Component\HttpFoundation\Request">Request</abbr>)) in /home/darek/Projekty/www/words2/web/app_dev.php line 28</li>
    </ol>
</div>

            </div>
    </body>
</html>